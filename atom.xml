<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Electric Dream</title>
  
  <subtitle>just try to do it</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/electricdream11/"/>
  <updated>2019-11-21T14:19:08.095Z</updated>
  <id>https://github.com/electricdream11/</id>
  
  <author>
    <name>fjb-fjb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨时钟传输</title>
    <link href="https://github.com/electricdream11/2019/11/21/%E8%B7%A8%E6%97%B6%E9%92%9F%E4%BC%A0%E8%BE%93/"/>
    <id>https://github.com/electricdream11/2019/11/21/跨时钟传输/</id>
    <published>2019-11-21T14:16:44.000Z</published>
    <updated>2019-11-21T14:19:08.095Z</updated>
    
    <content type="html"><![CDATA[<pre><code>跨时钟传输模型</code></pre><h1 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h1><p>在学习使用IP核后本想逐渐的使用IP核来提高设计的水平，奈何IP核不能做时序仿真，需要权限，所以以后再学习理论性的概念时最好不要使用IP核，除非只是基于功能的仿真。</p><h1 id="二、跨时钟数据传输"><a href="#二、跨时钟数据传输" class="headerlink" title="二、跨时钟数据传输"></a>二、跨时钟数据传输</h1><p>在两个时钟频率不同的区域间传输数据，考虑实际的寄存延时，通过实际的设计，达到理解时序在设计过程中的标尺的作用内涵，将时序设计贯彻到实际的设计中去。</p><h1 id="三、功能实现"><a href="#三、功能实现" class="headerlink" title="三、功能实现"></a>三、功能实现</h1><p>1、原理图设计</p><p>2、代码设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">module max_top(</span><br><span class="line">input Clk_50M,</span><br><span class="line">input Clk_100M,</span><br><span class="line">input Rst_n,</span><br><span class="line">input data_s,</span><br><span class="line"></span><br><span class="line">output reg data_a,</span><br><span class="line">output reg data_b</span><br><span class="line">);</span><br><span class="line">//middle parameter</span><br><span class="line">reg data_a_tp;</span><br><span class="line">reg data_b_tp;</span><br><span class="line">//first level</span><br><span class="line">always@(posedge Clk_50M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_a_tp &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">   data_a_tp &lt;= data_s;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_b_tp &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">   data_b_tp &lt;= data_s;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">// next level</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_a &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">data_a &lt;= data_a_tp;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_b &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">data_b &lt;= data_b_tp;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>3、功能仿真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_p1 20</span><br><span class="line">`define Clk_p2 10</span><br><span class="line"></span><br><span class="line">module max_top_tb;</span><br><span class="line"></span><br><span class="line">//input Clk_50M,</span><br><span class="line">//input Clk_100M,</span><br><span class="line">//input Rst_n,</span><br><span class="line">//input data_s,</span><br><span class="line"></span><br><span class="line">//output reg data_a,</span><br><span class="line">//output reg data_b</span><br><span class="line"></span><br><span class="line">reg Clk_50M=1&apos;b0;</span><br><span class="line">reg Clk_100M=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line">reg data_s=1&apos;b0;</span><br><span class="line"></span><br><span class="line">wire data_a;</span><br><span class="line">wire data_b;</span><br><span class="line"></span><br><span class="line">max_top max_top_U1(</span><br><span class="line">.Clk_50M(Clk_50M),</span><br><span class="line">.Clk_100M(Clk_100M),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.data_s(data_s),</span><br><span class="line"></span><br><span class="line">.data_a(data_a),</span><br><span class="line">.data_b(data_b)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always #(`Clk_p1/2) Clk_50M = ~Clk_50M ; </span><br><span class="line">always #(`Clk_p2/2) Clk_100M = ~Clk_100M;</span><br><span class="line"></span><br><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">#(`Clk_p1*10)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">   #(`Clk_p1*10)</span><br><span class="line">data_s = 1&apos;b1;</span><br><span class="line">#(`Clk_p1*10)</span><br><span class="line">data_s = 1&apos;b0;</span><br><span class="line">#(`Clk_p1*10)</span><br><span class="line">data_s = 1&apos;b1;</span><br><span class="line">#(`Clk_p1*10)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h1 id="四、管脚分配与连接"><a href="#四、管脚分配与连接" class="headerlink" title="四、管脚分配与连接"></a>四、管脚分配与连接</h1><p>不用板级验证，可以直接跳过。<br>五、时序分析与优化<br>1、时钟约束<br>只能约束一个时钟，多个时钟约束的分析还没熟悉<br>2、时序分析<br>还能用，前面的一个部分有一点错误，所以没有找到。</p><h1 id="六、反思总结"><a href="#六、反思总结" class="headerlink" title="六、反思总结"></a>六、反思总结</h1><p>这部分的学习还是得先掌握时钟域的分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;跨时钟传输模型&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h1&gt;&lt;p&gt;在学习使用IP核后本想逐渐的使用IP核来提高设计的水平，奈何I
      
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>跨时钟数据传输</title>
    <link href="https://github.com/electricdream11/2019/11/18/%E8%B7%A8%E6%97%B6%E9%92%9F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <id>https://github.com/electricdream11/2019/11/18/跨时钟数据传输/</id>
    <published>2019-11-18T12:52:22.000Z</published>
    <updated>2019-11-18T12:56:32.253Z</updated>
    
    <content type="html"><![CDATA[<pre><code>跨时钟数据传输</code></pre><h1 id="一、学习背景"><a href="#一、学习背景" class="headerlink" title="一、学习背景"></a>一、学习背景</h1><p>在学习了如何产生多时钟频率后，自然而然的就要考虑如何将其引入到实际的设计中去。跨时钟设计中最简单的就是同相异频的数据传输模型，这也是跨时钟中最简单并且实用的模型。与此同时，学习这个模型也可以为异频异相的传输打下基础。</p><a id="more"></a><h1 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h1><p>掌握好数据跨时钟传输模型，并借此以提高数据的传输的灵活性。数据跨时钟是在同步时钟后的又一个难点，具体的了解这个模型对时序的理解也是重要的途径。</p><h1 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h1><p>使用PLL锁相环得到两个不同频率时钟，分别驱动两个部分。在两个部分的连接处使用不同的方法以提高数据传输的准确性。根据数据传输的时序模型来了解实际的数据传输设置，包括高频到低频和低频到高频的两种模型。</p><h1 id="四、实验操作"><a href="#四、实验操作" class="headerlink" title="四、实验操作"></a>四、实验操作</h1><h2 id="1、功能设计"><a href="#1、功能设计" class="headerlink" title="1、功能设计"></a>1、功能设计</h2><p>（1）功能定义<br>使用PLL实现两个时钟的输出，构建两个数据传输路径，一个由高频到低频，一个反之。还有一个全局的复位信号和时钟复位信号。输出则是根据实际的需求来使用的。<br>（2）代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input [1:0] data_in,</span><br><span class="line"></span><br><span class="line">output locked,</span><br><span class="line">output  Clk_50M,</span><br><span class="line">output  Clk_100M,</span><br><span class="line">output reg [1:0] data_out1,</span><br><span class="line">output reg [1:0] data_out2,</span><br><span class="line">output reg [1:0] data_out1_temp,</span><br><span class="line">   output reg [1:0] data_out2_temp</span><br><span class="line">);</span><br><span class="line">reg Rst_clk;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> PLL PLL_U1(</span><br><span class="line">.areset(Rst_clk),</span><br><span class="line">.inclk0(Clk),</span><br><span class="line">.c0(Clk_50M),</span><br><span class="line">.c1(Clk_100M),</span><br><span class="line">.locked(locked)</span><br><span class="line">);</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Rst_clk &lt;= 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">Rst_clk &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk_50M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_out1_temp &lt;= 2&apos;b0;</span><br><span class="line">elseif(locked)</span><br><span class="line">data_out1_temp &lt;= data_in;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_out1 &lt;= 2&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_out1 &lt;= data_out1_temp;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_out2_temp &lt;= 2&apos;b0;</span><br><span class="line">elseif(locked)</span><br><span class="line">data_out2_temp &lt;= data_in;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_50M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_out2 &lt;= 2&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_out2 &lt;= data_out2_temp;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/18/跨时钟数据传输/imag_001.png"><p>（3）功能仿真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20</span><br><span class="line"></span><br><span class="line">module top_tb;</span><br><span class="line"></span><br><span class="line">reg Clk=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line">reg [1:0] data_in=2&apos;b0;</span><br><span class="line"></span><br><span class="line">wire locked;</span><br><span class="line">wire  Clk_50M;</span><br><span class="line">wire  Clk_100M;</span><br><span class="line">wire  [1:0] data_out1;</span><br><span class="line">wire  [1:0] data_out2;</span><br><span class="line">wire  [1:0] data_out1_temp;</span><br><span class="line">wire  [1:0] data_out2_temp;</span><br><span class="line">top top_tb_U1(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.data_in(data_in),</span><br><span class="line"></span><br><span class="line">.locked(locked),</span><br><span class="line">. Clk_50M(Clk_50M),</span><br><span class="line">. Clk_100M(Clk_100M),</span><br><span class="line">.data_out1(data_out1),</span><br><span class="line">.data_out2(data_out2),</span><br><span class="line">.data_out1_temp(data_out1_temp),</span><br><span class="line">.data_out2_temp(data_out2_temp)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always #(`Clk_period) Clk = ~ Clk;</span><br><span class="line"></span><br><span class="line">initial </span><br><span class="line">begin</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b0;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">data_in = 2&apos;b01;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">data_in = 2&apos;b10;</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">data_in = 2&apos;b11;</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">data_in = 2&apos;b00;</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/18/跨时钟数据传输/imag_002.png"><p>（4）功能分析<br>从理想的功能仿真可以看到，先传到50M频的寄存器再到100M频的寄存器的数据传输要比先到100M频的寄存器再到50M频的数据传输要快一个100M时钟周期。即假设在前一个寄存器的数据同步变化，后一个寄存器在各自时钟周期后变化。</p><h2 id="2、时序设计"><a href="#2、时序设计" class="headerlink" title="2、时序设计"></a>2、时序设计</h2><p>（1）时钟约束<br>时钟约束依旧已经在IP核中自动设置完成。<br>（2）接口约束<br>这部分的约束好像没有解决，时序约束部分还有些没有理解的部分。可以考虑先用时序分析来解决，后仿真在后面学习完了在进行。<br>（3）路径约束<br>（4）时序仿真<br>（5）时序分析</p><h2 id="3、布局布线"><a href="#3、布局布线" class="headerlink" title="3、布局布线"></a>3、布局布线</h2><p>略</p><h1 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h1><p>现在发现时序约束还有比较多的工具还没有了解到，导致实验的结果没有满足实际的设计的思路。接下来的要对这部分的知识补充一下。这次最好能够将所有的后仿真的文件和概念都分析清楚。每次都烂尾的感觉真不好。</p><h1 id="六、反思总结"><a href="#六、反思总结" class="headerlink" title="六、反思总结"></a>六、反思总结</h1><p>EDA工具的了解要深刻，不能知识选择性的使用，否则在使用是可能会出现设置错误从而耽误时间。这两天的时序分析就是最好的例子。而且，有可能的化尽可能的选择多种方式进行，以减少相应的时间的耽误。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;跨时钟数据传输&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习背景&quot;&gt;&lt;a href=&quot;#一、学习背景&quot; class=&quot;headerlink&quot; title=&quot;一、学习背景&quot;&gt;&lt;/a&gt;一、学习背景&lt;/h1&gt;&lt;p&gt;在学习了如何产生多时钟频率后，自然而然的就要考虑如何将其引入到实际的设计中去。跨时钟设计中最简单的就是同相异频的数据传输模型，这也是跨时钟中最简单并且实用的模型。与此同时，学习这个模型也可以为异频异相的传输打下基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>多时钟时序测试（失败）</title>
    <link href="https://github.com/electricdream11/2019/11/16/%E5%A4%9A%E6%97%B6%E9%92%9F%E6%97%B6%E5%BA%8F%E6%B5%8B%E8%AF%95%EF%BC%88%E5%A4%B1%E8%B4%A5%EF%BC%89/"/>
    <id>https://github.com/electricdream11/2019/11/16/多时钟时序测试（失败）/</id>
    <published>2019-11-16T13:18:26.000Z</published>
    <updated>2019-11-18T12:59:56.503Z</updated>
    
    <content type="html"><![CDATA[<pre><code>多时钟设计原理</code></pre><h1 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h1><p>在掌握了利用PLL产生多时钟后，使用多时钟设计并利用其提高设计的速度是当下的重要目的。所谓的多时钟设计就是根据不同的速度要求制定不同的实现方法。为了更好的掌握这种层次的设计，需要具体的去体验这个问题。</p><a id="more"></a><h1 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h1><p>实现多时钟设计的基本优化。为了加强这个方面的能力，解决在时序中主要的问题，可以尝试对不同时钟下的设计。</p><h1 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h1><p>构建一条基础的数据传输链，利用PLL产生的时钟实现高速传输，并且实现时序约束。数据传输链这次会复杂一点，以体现多时钟的优势。</p><h1 id="四、实验操作"><a href="#四、实验操作" class="headerlink" title="四、实验操作"></a>四、实验操作</h1><h2 id="1、功能设计"><a href="#1、功能设计" class="headerlink" title="1、功能设计"></a>1、功能设计</h2><p>（1）功能定义<br>一条50M的数据传输链，在时序充足的地方引入100M的时钟加速。对比得到多时钟设计的优势。并且对时序余量设计的初步的把握。当下的感觉是对实际的问题的解决没有明确的概念。具体的方法还是要在具有实际功能的设计中理解。相应的技巧的阅读也要跟上。知识跟不上会导致设计脱离实践的速度。<br>（2）代码实现<br>！下一次还是回归简单的芯片，可以减少设计时的编译时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">module top(</span><br><span class="line">input Clk_50M,</span><br><span class="line">input Rst_n,</span><br><span class="line">input [1:0] Data_in,</span><br><span class="line"></span><br><span class="line">output reg [1:0] Data_out,</span><br><span class="line">output reg [1:0] Data_out_fast,</span><br><span class="line">output wire Clk_100M,</span><br><span class="line">output wire locked</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">wire Rst;</span><br><span class="line"></span><br><span class="line">wire Clk1;</span><br><span class="line">wire Clk2;</span><br><span class="line"></span><br><span class="line">assign Rst = ~Rst_n;</span><br><span class="line">assign Clk_100M = Clk2;</span><br><span class="line"></span><br><span class="line">PLL PLL_clock_U1(</span><br><span class="line">.refclk(Clk_50M),   //  refclk.clk</span><br><span class="line">.rst(Rst),      //   reset.reset</span><br><span class="line"></span><br><span class="line">.outclk_0(Clk1), // outclk0.clk</span><br><span class="line">.outclk_1(Clk2), // outclk1.clk</span><br><span class="line">.locked(locked)    //  locked.export</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always@(posedge Clk1 or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Data_out &lt;= 2&apos;b00;</span><br><span class="line">else if(locked)</span><br><span class="line">begin</span><br><span class="line">Data_out &lt;= Data_out;</span><br><span class="line">Data_out &lt;= Data_in + 1&apos;b1;</span><br><span class="line">end</span><br><span class="line">else </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">always@(posedge Clk2 or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Data_out_fast &lt;= 2&apos;b00;</span><br><span class="line">else if(locked)</span><br><span class="line">begin</span><br><span class="line">Data_out_fast &lt;= Data_out_fast;</span><br><span class="line">Data_out_fast &lt;= Data_in + 1&apos;b1;</span><br><span class="line">end</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>（3）功能仿真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20</span><br><span class="line"></span><br><span class="line">module top_tb;</span><br><span class="line">reg Clk_50M=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line">reg [1:0] Data_in=1&apos;b0;</span><br><span class="line"></span><br><span class="line">wire [1:0] Data_out;</span><br><span class="line">wire [1:0] Data_out_fast;</span><br><span class="line">wire Clk_100M;</span><br><span class="line">wire locked;</span><br><span class="line"></span><br><span class="line">top top_tb_U1(</span><br><span class="line">.Clk_50M(Clk_50M),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.Data_in(Data_in),</span><br><span class="line"></span><br><span class="line">.Data_out(Data_out),</span><br><span class="line">.Data_out_fast(Data_out_fast),</span><br><span class="line">.Clk_100M(Clk_100M),</span><br><span class="line">.locked(locked)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always #(`Clk_period/2) Clk_50M = ~Clk_50M;</span><br><span class="line"></span><br><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b0;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">#(`Clk_period)</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="2、时序设计"><a href="#2、时序设计" class="headerlink" title="2、时序设计"></a>2、时序设计</h2><p>（1）时钟约束<br>由于使用了PLL时钟单元，所有的时钟约束都已经自动的载入了，而没有使用衍生时钟，所以这部分的工作已经完成。<br>（2）路径约束<br>（3）接口约束<br>（4）时序仿真<br>!仿真工具有点问题，好像不支持PLL的时序仿真，这需要更新软件，这部分先暂时等一下理论的学习。</p><h2 id="3、综合设计"><a href="#3、综合设计" class="headerlink" title="3、综合设计"></a>3、综合设计</h2><p>（1）IO约束<br>（2）布局布线<br>（3）综合网表</p><h1 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h1><p>由于EDA工具被迫中止。</p><h1 id="六、反思总结"><a href="#六、反思总结" class="headerlink" title="六、反思总结"></a>六、反思总结</h1><p>这段时间的时间以复习为主，相应的理论知识还没有跟上。相应的软件的更新也没有准备好。尽快处理好这些问题，保证时间上能够完成学习要求。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;多时钟设计原理&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、背景知识&quot;&gt;&lt;a href=&quot;#一、背景知识&quot; class=&quot;headerlink&quot; title=&quot;一、背景知识&quot;&gt;&lt;/a&gt;一、背景知识&lt;/h1&gt;&lt;p&gt;在掌握了利用PLL产生多时钟后，使用多时钟设计并利用其提高设计的速度是当下的重要目的。所谓的多时钟设计就是根据不同的速度要求制定不同的实现方法。为了更好的掌握这种层次的设计，需要具体的去体验这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>PLL时钟管理</title>
    <link href="https://github.com/electricdream11/2019/11/15/PLL%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://github.com/electricdream11/2019/11/15/PLL时钟管理/</id>
    <published>2019-11-15T13:01:34.000Z</published>
    <updated>2019-11-15T13:07:23.295Z</updated>
    
    <content type="html"><![CDATA[<pre><code>PLL时钟管理</code></pre><h1 id="一、知识背景"><a href="#一、知识背景" class="headerlink" title="一、知识背景"></a>一、知识背景</h1><p>PLL在Arria10中有EPLL（增强型锁相环）可以实现分频和倍频的操作。在Cyclone10中只有FPLL（快速锁相环），实现对时钟的操作。为了学习多时钟的管理手段，首先得学会多时钟的产生。</p><a id="more"></a><h1 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h1><p>使用FPLL实现多种时钟的输出，并总结时钟之间的差距。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><h2 id="1、功能构建"><a href="#1、功能构建" class="headerlink" title="1、功能构建"></a>1、功能构建</h2><p>（1）功能定义<br>输入一个时钟，经过一个FPLL输出5个时钟，并利用这5个时钟完成数据传输测试。可以和上次的测试对比，可以大概知道PLL和DLL的区别所在。当然，xilin的DLL具有专门的优化，和自己设计的有所不同。<br>（2）代码实现<br>！FPLL中areset为高电平有效复位信号，locked为输出稳定高电平标志信号<br>！使用locked的高电平有效可以保证时钟使用的同步性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk_50M_in,</span><br><span class="line">input Rst_n,</span><br><span class="line">input data,</span><br><span class="line"></span><br><span class="line">output  Clk_25M,</span><br><span class="line">output  Clk_50M,</span><br><span class="line">output  Clk_100M,</span><br><span class="line">output  Clk_150M,</span><br><span class="line">output  Clk_200M,</span><br><span class="line">output wire locked,</span><br><span class="line">output reg data_25M,</span><br><span class="line">output reg data_50M,</span><br><span class="line">output reg data_100M,</span><br><span class="line">output reg data_150M,</span><br><span class="line">output reg data_200M</span><br><span class="line">);</span><br><span class="line">wire rst;</span><br><span class="line">assign rst = ~ Rst_n;</span><br><span class="line"></span><br><span class="line">FPLL FPLL_U1(</span><br><span class="line">.areset(rst),</span><br><span class="line">.inclk0(Clk_50M_in),</span><br><span class="line">.c0(Clk_50M),</span><br><span class="line">.c1(Clk_100M),</span><br><span class="line">.c2(Clk_150M),</span><br><span class="line">.c3(Clk_200M),</span><br><span class="line">.c4(Clk_25M),</span><br><span class="line">.locked(locked)</span><br><span class="line">);</span><br><span class="line">always@(posedge Clk_50M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_50M &lt;= 1&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_50M &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_100M &lt;= 1&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_100M &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_150M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_150M &lt;= 1&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_150M &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_200M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_200M &lt;= 1&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_200M &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_25M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_25M &lt;= 1&apos;b0;</span><br><span class="line">else if(locked)</span><br><span class="line">data_25M &lt;= data;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/15/PLL时钟管理/imag_001.png"><p>（3）仿真测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20</span><br><span class="line"></span><br><span class="line">module max_tb;</span><br><span class="line">reg  Clk_50M_in = 1&apos;b0;</span><br><span class="line">reg  Rst_n  = 1&apos;b0;</span><br><span class="line">reg  data  = 1&apos;b1;</span><br><span class="line"></span><br><span class="line">wire  Clk_25M;</span><br><span class="line">wire  Clk_50M;</span><br><span class="line">wire  Clk_100M;</span><br><span class="line">wire  Clk_150M;</span><br><span class="line">wire  Clk_200M;</span><br><span class="line">wire  locked;</span><br><span class="line">wire  data_25M;</span><br><span class="line">wire  data_50M;</span><br><span class="line">wire  data_100M;</span><br><span class="line">wire  data_150M;</span><br><span class="line">wire  data_200M;</span><br><span class="line"></span><br><span class="line">max max_tb_U1(</span><br><span class="line">.Clk_50M_in(Clk_50M_in),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.data(data),</span><br><span class="line"></span><br><span class="line">.Clk_25M(Clk_25M),</span><br><span class="line">.Clk_50M(Clk_50M),</span><br><span class="line">.Clk_100M(Clk_100M),</span><br><span class="line">.Clk_150M(Clk_150M),</span><br><span class="line">.Clk_200M(Clk_200M),</span><br><span class="line">.locked(locked),</span><br><span class="line">.data_25M(data_25M),</span><br><span class="line">.data_50M(data_50M),</span><br><span class="line">.data_100M(data_100M),</span><br><span class="line">.data_150M(data_150M),</span><br><span class="line">.data_200M(data_200M)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always #(`Clk_period/2) Clk_50M_in = ~ Clk_50M_in;</span><br><span class="line"></span><br><span class="line">initial </span><br><span class="line">begin</span><br><span class="line">#(`Clk_period)</span><br><span class="line">data = 1&apos;b1;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/15/PLL时钟管理/imag_002.png"><h2 id="2、时序约束"><a href="#2、时序约束" class="headerlink" title="2、时序约束"></a>2、时序约束</h2><p>（1）时钟约束<br>该实验中时钟约束有输入时钟Clk_50M_in和其他五个衍生时钟</p><img src="/2019/11/15/PLL时钟管理/imag_003.png"><p>可以看到在使用PLL是设置的输入时钟频率直接被加载为时钟约束了。这也是使用PLL锁相环的优势之一，在时序仿真时可以省略自己添加时钟约束的步骤。<br>（2）IO约束<br>以1ns约束所有的输入管脚到信号之间的时间。使用0.1ns约束信号到输出间的延时。</p><img src="/2019/11/15/PLL时钟管理/imag_004.png"><p>输出接口以同样的方法实现<br>（3）路径约束<br>由于只是测试了输出传输，只有一次数据寄存，所以除了200M时钟的时序余量不足外其他还好。初次尝试对多时钟管理，很显然是十分困难的。使用timing analysis对单一时钟约束时还好，但在对多时钟和多路径时约束显得很困难。</p><img src="/2019/11/15/PLL时钟管理/imag_005.png"><p>这里应该要接触一些高级的设计约束手段来实现多时钟的管理，这也是接下来要学习的。使用多时钟的分类约束可以实现约束仿真的高效实现。</p><h2 id="3、布局布线"><a href="#3、布局布线" class="headerlink" title="3、布局布线"></a>3、布局布线</h2><p>不需要板级验证，IO就不设置了</p><h2 id="4、时序约束"><a href="#4、时序约束" class="headerlink" title="4、时序约束"></a>4、时序约束</h2><p>略，这个期间好像不支持时序仿真，也可能是没有准备相应的组件。</p><h1 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h1><p>初步的了解了PLL产生多时钟的方法，对产生时钟的功能上进行了有效验证。有序多时钟的时序不叫复杂，所以还没有实现有效。有序多时钟的时序比较复杂，所以还没有实现有效的时序仿真，时序约束也是尝试了一下就停止了。</p><h1 id="五、总结反思"><a href="#五、总结反思" class="headerlink" title="五、总结反思"></a>五、总结反思</h1><p>多时钟的时序管理是必须的。在大规模的设计中，了解多时钟可以使设计能够满足整体的要求而不至于与团队脱节。所以，虽然多时钟管理比较复杂，但这是必须掌握的方法。另外，从设计手段出发，多时钟设计也是重要的提高速度的手段。对于使用这方面的内容，依靠参考书和设计时的思考是非常重要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;PLL时钟管理&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、知识背景&quot;&gt;&lt;a href=&quot;#一、知识背景&quot; class=&quot;headerlink&quot; title=&quot;一、知识背景&quot;&gt;&lt;/a&gt;一、知识背景&lt;/h1&gt;&lt;p&gt;PLL在Arria10中有EPLL（增强型锁相环）可以实现分频和倍频的操作。在Cyclone10中只有FPLL（快速锁相环），实现对时钟的操作。为了学习多时钟的管理手段，首先得学会多时钟的产生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>设计时的多时钟时序约束</title>
    <link href="https://github.com/electricdream11/2019/11/14/%E8%AE%BE%E8%AE%A1%E6%97%B6%E7%9A%84%E5%A4%9A%E6%97%B6%E9%92%9F%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F/"/>
    <id>https://github.com/electricdream11/2019/11/14/设计时的多时钟时序约束/</id>
    <published>2019-11-14T13:24:17.000Z</published>
    <updated>2019-11-14T13:27:34.819Z</updated>
    
    <content type="html"><![CDATA[<pre><code>设计中的多时钟时序约束</code></pre><h1 id="一、学习背景"><a href="#一、学习背景" class="headerlink" title="一、学习背景"></a>一、学习背景</h1><p>在学习了单时钟的时钟约束条件后，自然而然的，就要考虑多时钟管理的方法。多时钟管理是FPGA设计走向高速的必经之路。掌握好时钟域的管理是应对时序设计的复杂的根本手段。</p><a id="more"></a><h1 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h1><p>为了学习多时钟的管理，首先得知道多时钟的来源–时钟分频。使用时钟分频可以有效地建立多时钟的练习。这也是简单的多时钟管理，可以为后面的异步时钟管理打下基础。</p><h1 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h1><p>使用时钟分频来输出多个时钟并且利用多个时钟控制不同层次的时序逻辑。这是实现时序的充分利用的有效方法。</p><h1 id="四、实验操作"><a href="#四、实验操作" class="headerlink" title="四、实验操作"></a>四、实验操作</h1><h2 id="1、功能设计"><a href="#1、功能设计" class="headerlink" title="1、功能设计"></a>1、功能设计</h2><p>（1）功能设计<br>！在自带PLL的芯片上可以直接实现倍频和分频操作。在没有的情况下使用分频时序也可以大致实现分频，但时序延时会累加。<br>（2）代码描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk_200M,</span><br><span class="line">input Rst_n,</span><br><span class="line">input data,</span><br><span class="line"></span><br><span class="line">output reg Clk_100M,</span><br><span class="line">output reg Clk_50M,</span><br><span class="line">output reg data_100M,</span><br><span class="line">output reg data_200M,</span><br><span class="line">output reg data_50M</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Clk_50M &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">Clk_50M &lt;= ~ Clk_50M;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_200M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Clk_100M &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">Clk_100M &lt;= ~ Clk_100M;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_50M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_50M &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">data_50M &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_100M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_100M &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">data_100M &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk_200M or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_200M &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">data_200M &lt;= data;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/14/设计时的多时钟时序约束/imag_001.png"><p>（3）功能仿真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 5</span><br><span class="line">module max_tb;</span><br><span class="line"></span><br><span class="line">reg Clk_200M=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line">reg data = 1&apos;b1;</span><br><span class="line"></span><br><span class="line">wire Clk_100M;</span><br><span class="line">wire Clk_50M;</span><br><span class="line">wire data_200M;</span><br><span class="line">wire data_100M;</span><br><span class="line">wire data_50M;</span><br><span class="line"></span><br><span class="line">max max_U1tb(</span><br><span class="line">.Clk_200M(Clk_200M),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.data(data),</span><br><span class="line"></span><br><span class="line">.Clk_100M(Clk_100M),</span><br><span class="line">.Clk_50M(Clk_50M),</span><br><span class="line">.data_200M(data_200M),</span><br><span class="line">.data_100M(data_100M),</span><br><span class="line">.data_50M(data_50M)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always #(`Clk_period/2) Clk_200M = ~Clk_200M;</span><br><span class="line"></span><br><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">Rst_n = 1&apos;b0;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">data = 1&apos;b1;</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/14/设计时的多时钟时序约束/imag_002.png"><h2 id="2、时序设计"><a href="#2、时序设计" class="headerlink" title="2、时序设计"></a>2、时序设计</h2><p>（1）全局时钟约束<br>由于只是使用寄存器实现的数字分频，分出的时钟与原时钟的相位不一样，不如锁相环的效果，所以要对衍生时钟考虑延时累计。</p><img src="/2019/11/14/设计时的多时钟时序约束/imag_003.png"><p>（2）管脚时序约束<br>根据实际的器件连接特性决定，测试时全部默认为1ns<br>（3）时序分析<br>从约束后的时钟可以看出200M的频率不能保证在MAXII–EPM240F100C4上有充足的时序余量（slack），为了可以得到具体的仿真图形，将200M的输入下调至100M，其他时钟一次倍除。</p><img src="/2019/11/14/设计时的多时钟时序约束/imag_004.png"><p>更改后还不能将自建时钟加入并列时钟约束，也不知道是不是要用其他方法，下一次使用PLL，也要换器件。这次先不把其视作时钟。<br>（4）时序仿真<br>！此时的时钟频率倍增了，注意和功能仿真时区别。</p><img src="/2019/11/14/设计时的多时钟时序约束/imag_005.png"><h2 id="3、布局布线"><a href="#3、布局布线" class="headerlink" title="3、布局布线"></a>3、布局布线</h2><p>目前还没有具体到板级验证或PCB设计，所有关于引脚和布局布线的内容暂时不考虑。</p><h1 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h1><p>从实验结果中可以看出，对于自己生成的时钟在仿真时会让系统的识别有一定问题。而且时钟延时的累加足够将时序余量耗尽。所以，多时钟使用时最好使用PLL去构建。</p><h1 id="六、反思总结"><a href="#六、反思总结" class="headerlink" title="六、反思总结"></a>六、反思总结</h1><p>多时钟管理是异步时钟的起点。在多时钟是主要需要考虑的时钟间的相位和频率的区别，再加上延时的影响。系统的管理方法在接下来的几天会逐步的接触。现在的主要的目标是把握多时钟下的时序设计。时钟的特点会对设计产生深远的影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;设计中的多时钟时序约束&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习背景&quot;&gt;&lt;a href=&quot;#一、学习背景&quot; class=&quot;headerlink&quot; title=&quot;一、学习背景&quot;&gt;&lt;/a&gt;一、学习背景&lt;/h1&gt;&lt;p&gt;在学习了单时钟的时钟约束条件后，自然而然的，就要考虑多时钟管理的方法。多时钟管理是FPGA设计走向高速的必经之路。掌握好时钟域的管理是应对时序设计的复杂的根本手段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>单时钟计数器</title>
    <link href="https://github.com/electricdream11/2019/11/13/%E5%8D%95%E6%97%B6%E9%92%9F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>https://github.com/electricdream11/2019/11/13/单时钟计数器/</id>
    <published>2019-11-13T14:06:20.000Z</published>
    <updated>2019-11-13T14:09:52.921Z</updated>
    
    <content type="html"><![CDATA[<pre><code>单时钟计数器</code></pre><h1 id="一、学习背景"><a href="#一、学习背景" class="headerlink" title="一、学习背景"></a>一、学习背景</h1><p>在初步的学习了FPGA的时序约束后，进行必要的时序训练是加深印象的必要手段。为了提高时序约束能力，在第一次的时序约束训练中会尽可能的考虑时序。将时序的问题融入到功能设计是合理设计的开始。</p><a id="more"></a><h1 id="二、学习目的"><a href="#二、学习目的" class="headerlink" title="二、学习目的"></a>二、学习目的</h1><p>通过实际的FPGA设计训练提高时序约束能力。</p><h1 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h1><p>构建一个单时钟计数器，通过合理的时序约束实现计数器的最大精度。</p><h1 id="四、实验操作"><a href="#四、实验操作" class="headerlink" title="四、实验操作"></a>四、实验操作</h1><h2 id="1-功能模块"><a href="#1-功能模块" class="headerlink" title="1.功能模块"></a>1.功能模块</h2><p>（1）功能定义<br>还是一个计数器，有一个级联结构，采用循环码提高时序余量，计数不循环，用进位表示计数结束。还是计数器，但要做到时序的最优。时序余量保持50%Clk，具有多器件的适应性，测试为MAXII的时序测试。<br>（2）功能实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg [3:0] tens_digit,</span><br><span class="line">output reg [3:0] units_digit,</span><br><span class="line">output reg       tens_carry</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg Rst_n_follow;</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">begin</span><br><span class="line">units_digit &lt;= 1&apos;b0;</span><br><span class="line">Rst_n_follow &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">else if(Rst_n_follow)</span><br><span class="line">case(units_digit)</span><br><span class="line">4&apos;b0000: units_digit &lt;= 4&apos;b0001;</span><br><span class="line">4&apos;b0001: units_digit &lt;= 4&apos;b0011;</span><br><span class="line">   4&apos;b0011: units_digit &lt;= 4&apos;b0010;</span><br><span class="line">4&apos;b0010: units_digit &lt;= 4&apos;b0110;</span><br><span class="line">4&apos;b0110: units_digit &lt;= 4&apos;b0111;</span><br><span class="line">4&apos;b0111: units_digit &lt;= 4&apos;b0101;</span><br><span class="line">4&apos;b0101: units_digit &lt;= 4&apos;b0100;</span><br><span class="line">4&apos;b0100: units_digit &lt;= 4&apos;b1100;</span><br><span class="line">4&apos;b1100: units_digit &lt;= 4&apos;b1000;</span><br><span class="line">4&apos;b1000: units_digit &lt;= 4&apos;b0000;</span><br><span class="line">default: units_digit &lt;= 4&apos;b0000;</span><br><span class="line"></span><br><span class="line">endcase</span><br><span class="line">else </span><br><span class="line">Rst_n_follow &lt;= 1&apos;b1;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">tens_digit &lt;= 1&apos;b0;</span><br><span class="line">else if(units_digit == 4&apos;b1000)</span><br><span class="line">begin</span><br><span class="line"> case(tens_digit)</span><br><span class="line">4&apos;b0000: tens_digit &lt;= 4&apos;b0001;</span><br><span class="line">4&apos;b0001: tens_digit &lt;= 4&apos;b0011;</span><br><span class="line">   4&apos;b0011: tens_digit &lt;= 4&apos;b0010;</span><br><span class="line">4&apos;b0010: tens_digit &lt;= 4&apos;b0110;</span><br><span class="line">4&apos;b0110: tens_digit &lt;= 4&apos;b0111;</span><br><span class="line">4&apos;b0111: tens_digit &lt;= 4&apos;b0101;</span><br><span class="line">4&apos;b0101: tens_digit &lt;= 4&apos;b0100;</span><br><span class="line">4&apos;b0100: tens_digit &lt;= 4&apos;b1100;</span><br><span class="line">4&apos;b1100: tens_digit &lt;= 4&apos;b1000;</span><br><span class="line">4&apos;b1000: tens_digit &lt;= 4&apos;b0000;</span><br><span class="line">default: tens_digit &lt;= 4&apos;b0000;</span><br><span class="line"></span><br><span class="line"> endcase</span><br><span class="line">   end</span><br><span class="line">else</span><br><span class="line"> ;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">tens_carry &lt;= 1&apos;b0;</span><br><span class="line">else if(tens_digit==4&apos;b1100&amp;&amp;units_digit==4&apos;b1100)</span><br><span class="line">tens_carry &lt;= 1&apos;b1;</span><br><span class="line">else </span><br><span class="line">tens_carry &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/13/单时钟计数器/imag_001.png"><p>（3）功能仿真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20</span><br><span class="line"></span><br><span class="line">module max_tb;</span><br><span class="line"></span><br><span class="line">reg Clk=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line"></span><br><span class="line">wire [3:0] units_digit;</span><br><span class="line">wire [3:0]  tens_digit;</span><br><span class="line">wire        tens_carry;</span><br><span class="line"></span><br><span class="line">max max_U1_tb(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.units_digit(units_digit),</span><br><span class="line">.tens_digit(tens_digit),</span><br><span class="line">.tens_carry(tens_carry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">always #(`Clk_period/2) Clk = ~ Clk;</span><br><span class="line"></span><br><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">#(`Clk_period)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`Clk_period * 100)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/13/单时钟计数器/imag_002.png"><h2 id="2-时序设计"><a href="#2-时序设计" class="headerlink" title="2.时序设计"></a>2.时序设计</h2><p>（1）时钟时序<br>时钟频率初步设置为50M标准时钟。时钟周期20ns。<br>(具体的操作在上一篇中有相应的图片）<br>（2）路径约束<br>50M时所有的路径都有余量。<br>（3）IO约束<br>全部的输入输出约束都以1ns为标准，这些数据来自实际的物理电路，不必细究，有实际的需求时再处理。要记住这个部分的可调整。<br>（4）时序仿真</p><img src="/2019/11/13/单时钟计数器/imag_003.png"><p>从时序仿真中可以看到相应的延时，但由于时钟的频率不高，不会影响正常的数据传输。<br>（5）加快时钟频率到200M<br>该设计在200M中的最紧张的是-3.08ns，依靠面积比较困难，可以尝试。</p><img src="/2019/11/13/单时钟计数器/imag_004.png"><p>（6）目前好像没有时序路径的优化手段。<br>3.综合<br>暂不考虑</p><h1 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h1><p>采用循环码实现的最大时钟约为10ns，其他的设计方法还未验证。可以在明天的实验中选择其他的设计方法实现。另外，学习一些其他的时序优化方法也是有利的。</p><h1 id="六、总结反思"><a href="#六、总结反思" class="headerlink" title="六、总结反思"></a>六、总结反思</h1><p>时序约束可以说是数字电路的核心，良好的时序设计习惯可以在设计之初就构成高速的性能特性，可以大量的节省时间。而时间，就可以继续转化为对设计的优化，最终达到高级电路的特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;单时钟计数器&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习背景&quot;&gt;&lt;a href=&quot;#一、学习背景&quot; class=&quot;headerlink&quot; title=&quot;一、学习背景&quot;&gt;&lt;/a&gt;一、学习背景&lt;/h1&gt;&lt;p&gt;在初步的学习了FPGA的时序约束后，进行必要的时序训练是加深印象的必要手段。为了提高时序约束能力，在第一次的时序约束训练中会尽可能的考虑时序。将时序的问题融入到功能设计是合理设计的开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>时序约束中的路径约束</title>
    <link href="https://github.com/electricdream11/2019/11/12/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E7%BA%A6%E6%9D%9F/"/>
    <id>https://github.com/electricdream11/2019/11/12/时序约束中的路径约束/</id>
    <published>2019-11-12T13:40:13.000Z</published>
    <updated>2019-11-12T13:45:31.748Z</updated>
    
    <content type="html"><![CDATA[<pre><code>时序约束中的路径约束</code></pre><h1 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h1><p>时序约束的基本约束为时钟约束，进一步的约束则是路径约束。路径约束是为了细化在某些地方的时序余量不足的问题。时钟约束给出了整体的约束，而路径约束则是在整体的情况下达到细节的优化。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>在某个包含时序数据传输和组合逻辑运算的模块中选择合理的路径约束以达到最高的速度和合理的面积的平衡。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><h2 id="1、功能设计"><a href="#1、功能设计" class="headerlink" title="1、功能设计"></a>1、功能设计</h2><p>（1）功能定义<br>为了方便学习路径约束和时钟约束及两者之间的平衡，暂定为3个数据传输路径。其中一条为数据到数据再到数据的三数据路径，另外一条为数据到运算到数据路径。最后一条为传输到数据。以这三条路径来优化以显示路径优化的基本分析和实现方法。<br>（2）功能实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input data,</span><br><span class="line"></span><br><span class="line">output reg  w1,</span><br><span class="line">output reg  w2,</span><br><span class="line">output reg  w3</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg  data_w1_cnt1;</span><br><span class="line">reg  data_w1_cnt2;</span><br><span class="line">reg  data_w2_cnt;</span><br><span class="line"></span><br><span class="line">wire w2_wire;</span><br><span class="line">wire w3_wire;</span><br><span class="line"></span><br><span class="line">//////////////////////////////////////////</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_w1_cnt1 &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">data_w1_cnt1 &lt;= data;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_w1_cnt2 &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">data_w1_cnt2 &lt;= data_w1_cnt1;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">w1 &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">w1 &lt;= data_w1_cnt2;</span><br><span class="line">end</span><br><span class="line">///////////////////////////////////////////</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">data_w2_cnt &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">data_w2_cnt &lt;= data;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assign w2_wire = data_w2_cnt;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">w2  &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">w2  &lt;= w2_wire;</span><br><span class="line">end</span><br><span class="line">/////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">assign w3_wire = data;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">w3 &lt;= 1&apos;b0;</span><br><span class="line">else</span><br><span class="line">w3 &lt;= w3_wire;</span><br><span class="line">end</span><br><span class="line">//////////////////////////////////////////////</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>（3）RTL视图</p><img src="/2019/11/12/时序约束中的路径约束/imag_001.png"><p>（4）功能仿真<br>比较简单，就不设计了。</p><h2 id="2、时序设计"><a href="#2、时序设计" class="headerlink" title="2、时序设计"></a>2、时序设计</h2><p>（1）全局时钟设计<br>创建全局时钟完成时钟约束。只有一个时钟，不需要考虑时钟域和异步时钟。<br>（2）路径约束<br>根据路径右击直接报告路径的时间约束。</p><img src="/2019/11/12/时序约束中的路径约束/imag_002.png"><p>也可以手动的选择路径来显示路径的时序要求。</p><img src="/2019/11/12/时序约束中的路径约束/imag_003.png"><p>从图中可以得到，已知的时序余量是在具体的器件延时的基础上得到的数据。在分析传输路径时，考虑到具体的时序路径可以对自己的时序有直观的印象。<br>如果不能满足路径时序要求时，则需要自己将时序余量进行均分以达到设计要求。当然也可以使用更加强大的芯片。<br>其他的路径也可以利用timing analysis分析，具体的约束需要利用要求来实现。<br>（3）IO时序约束<br>为了更加贴近实际的时序要求，IO是可以设置接口延时的。在比较准确的时序要求中，IO延时的约束也是十分重要的。<br>3、综合布线<br>略（事实上，FPGA在布线上也是可以优化的，目前还未接触到）</p><h1 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h1><p>基本的完成了前后仿真的所有的基本操作。有了这些操作就可以尝试了解设计过程中的每个细节。</p><h1 id="五、反思总结"><a href="#五、反思总结" class="headerlink" title="五、反思总结"></a>五、反思总结</h1><p>这些只是十分基本的操作，没有结合实际的需求来实现自己的设计。现在知识大概的了解时序分析与约束的具体的流程。接下来就要考虑开始进行实际的前后仿真设计。时序设计在实际的应用中有许多的高级的方法，这需要在实际的设计中不断地接触。现在就是做好准备而已。<br>时序的合理性直接的反应到设计的速度等级。良好的时序是一个设计可应用的关键。而速度的提升也是FPGA功能的体现。<br>下面的学习要接触比较高级的时序约束方法和规范的功能设计方法，打好基础，才能真正的深入到实际的设计中去。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;时序约束中的路径约束&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、背景知识&quot;&gt;&lt;a href=&quot;#一、背景知识&quot; class=&quot;headerlink&quot; title=&quot;一、背景知识&quot;&gt;&lt;/a&gt;一、背景知识&lt;/h1&gt;&lt;p&gt;时序约束的基本约束为时钟约束，进一步的约束则是路径约束。路径约束是为了细化在某些地方的时序余量不足的问题。时钟约束给出了整体的约束，而路径约束则是在整体的情况下达到细节的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>二进制计数器时钟约束</title>
    <link href="https://github.com/electricdream11/2019/11/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%B6%E9%92%9F%E7%BA%A6%E6%9D%9F/"/>
    <id>https://github.com/electricdream11/2019/11/11/二进制计数器时钟约束/</id>
    <published>2019-11-11T14:12:41.000Z</published>
    <updated>2019-11-11T14:15:17.806Z</updated>
    
    <content type="html"><![CDATA[<pre><code>二进制计数器</code></pre><h1 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h1><p>在简单的计数模型中实现时序分析和时序约束。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>根据数据传输模型中的时序约束要求，将原始的模型约束到最大的时序功能。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><h2 id="1-构建功能电路"><a href="#1-构建功能电路" class="headerlink" title="1.构建功能电路"></a>1.构建功能电路</h2><p>（1）功能划分<br>有一个计数器和高低电平的标志位。<br>（2）代码书写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg q</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">reg [24:0] cou_cnt;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">cou_cnt &lt;= 25&apos;d0;</span><br><span class="line">else if(cou_cnt == 25&apos;d24_999_999)</span><br><span class="line">cou_cnt &lt;= 25&apos;d0;</span><br><span class="line">else </span><br><span class="line">cou_cnt &lt;= cou_cnt + 1&apos;b1;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">q &lt;= 1&apos;b0;</span><br><span class="line">else if(cou_cnt &lt;= 25&apos;d24_999_999)</span><br><span class="line">q &lt;= ~q;</span><br><span class="line">else</span><br><span class="line">q &lt;= q;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/11/二进制计数器时钟约束/imag_001.png"><p>（3）功能仿真<br>功能较简单，不做仿真。</p><h2 id="2-时序分析"><a href="#2-时序分析" class="headerlink" title="2.时序分析"></a>2.时序分析</h2><p>（1）时序报告<br>在全编译后会出现所有的信息报告，其中包括时序报告，这也是初步的时序基础，是后面的工作的前提。</p><img src="/2019/11/11/二进制计数器时钟约束/imag_002.png"><p>（2）时钟的频率设置<br>通过时钟约束将时钟频率告诉软件，用于综合。<br>约束过程，使用Timing Analysis快速实现。<br>·创建时钟频率约束的代号：为布局布线和仿真提供参考。</p><img src="/2019/11/11/二进制计数器时钟约束/imag_003.png"><p>·刷新时钟频率约束：时钟代号要一致。<br>·其他的操作以后再慢慢熟悉。<br>（3）实际约束<br>根据实际的需求构建每一路径的时序要求。这需要实际的设计经验，以后再去做。今天就先做时钟约束。</p><h1 id="四、总结反思"><a href="#四、总结反思" class="headerlink" title="四、总结反思"></a>四、总结反思</h1><p>在实际的约束工具中进行时序约束是在设计中的基本操作，需要不断地练习和理解以达到融汇贯通的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;二进制计数器&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习目标&quot;&gt;&lt;a href=&quot;#一、学习目标&quot; class=&quot;headerlink&quot; title=&quot;一、学习目标&quot;&gt;&lt;/a&gt;一、学习目标&lt;/h1&gt;&lt;p&gt;在简单的计数模型中实现时序分析和时序约束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>数据传输中的时序分析</title>
    <link href="https://github.com/electricdream11/2019/11/10/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/electricdream11/2019/11/10/数据传输中的时序分析/</id>
    <published>2019-11-10T13:27:04.000Z</published>
    <updated>2019-11-10T13:36:37.956Z</updated>
    
    <content type="html"><![CDATA[<pre><code>数据传输中的时序约束</code></pre><h1 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h1><h2 id="1-FPGA的基本原理"><a href="#1-FPGA的基本原理" class="headerlink" title="1.FPGA的基本原理"></a>1.FPGA的基本原理</h2><p>（1）FPGA可以使用JTAG、AS、PS等方式实现现场可编程的功能。基本层次为门，基本的实现结构为门阵列。<br>（2）FPGA的三要素<br>可编程逻辑块、内部互联线（PIC）、输出输入块。<br>可编程逻辑功能块：查找表、D触发器、进位链···<br>可编程输入输出块：输出寄存器、输入寄存器、输入延时链、输出延时链、上拉电阻···<br>可编程内部互联资源：连接线、可控的连线开关、局部高速通道···</p><a id="more"></a><h2 id="2-FPGA的时序"><a href="#2-FPGA的时序" class="headerlink" title="2.FPGA的时序"></a>2.FPGA的时序</h2><p>（1）时序的意义<br>将使用的资源合理分配以提高某些数据间的速度以满足实际要求。<br>（2）FPGA的拓展资源<br>存储器、数字时钟管理单元、算数运算单元、高速IO、特殊功能模块、微处理器···<br>（3）FPGA时序分析和时序约束<br>时序分析的目的就是验证整个系统是否可以合理寄存数据，<br>数据和时钟传输路径由EDA软件布局布线实现的。<br>时序约束的目的就是设置时序目标和协助EDA分析时序路径。</p><h1 id="二、时序分析的基本模型"><a href="#二、时序分析的基本模型" class="headerlink" title="二、时序分析的基本模型"></a>二、时序分析的基本模型</h1><p>1.代码模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line"></span><br><span class="line">input a,</span><br><span class="line">input b,</span><br><span class="line"></span><br><span class="line">output reg c</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg a_reg;</span><br><span class="line">reg b_reg;</span><br><span class="line"></span><br><span class="line">wire c_wire;</span><br><span class="line"></span><br><span class="line">always@(posedge Clk)</span><br><span class="line">begin</span><br><span class="line">a_reg &lt;= a;</span><br><span class="line">b_reg &lt;= b;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assign  c_wire = a_reg &amp;&amp; b_reg;</span><br><span class="line"></span><br><span class="line">always@(posedge Clk)</span><br><span class="line">c &lt;= c_wire;</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/10/数据传输中的时序分析/imag_001.png"><p>寄存器传输模型及数据传输路径。<br>2.实际的时序波形逻辑模型<br>！个人感觉数据的时序约束就是保证在一个时钟周期内输入数据与输出数据不矛盾。</p><img src="/2019/11/10/数据传输中的时序分析/imag_002.png"><p>3.实际仿真波形模型<br>需要增加时序约束，稍后再学习。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>大概的了解了数据传输过程中需要的时序条件，为时序分析和时序约束打下了基础。接下来的学习会通过具体的实例来接触时序分析的操作和具体原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;数据传输中的时序约束&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、背景知识&quot;&gt;&lt;a href=&quot;#一、背景知识&quot; class=&quot;headerlink&quot; title=&quot;一、背景知识&quot;&gt;&lt;/a&gt;一、背景知识&lt;/h1&gt;&lt;h2 id=&quot;1-FPGA的基本原理&quot;&gt;&lt;a href=&quot;#1-FPGA的基本原理&quot; class=&quot;headerlink&quot; title=&quot;1.FPGA的基本原理&quot;&gt;&lt;/a&gt;1.FPGA的基本原理&lt;/h2&gt;&lt;p&gt;（1）FPGA可以使用JTAG、AS、PS等方式实现现场可编程的功能。基本层次为门，基本的实现结构为门阵列。&lt;br&gt;（2）FPGA的三要素&lt;br&gt;可编程逻辑块、内部互联线（PIC）、输出输入块。&lt;br&gt;可编程逻辑功能块：查找表、D触发器、进位链···&lt;br&gt;可编程输入输出块：输出寄存器、输入寄存器、输入延时链、输出延时链、上拉电阻···&lt;br&gt;可编程内部互联资源：连接线、可控的连线开关、局部高速通道···&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>always块的级联设计</title>
    <link href="https://github.com/electricdream11/2019/11/08/always%E5%9D%97%E7%9A%84%E7%BA%A7%E8%81%94%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/electricdream11/2019/11/08/always块的级联设计/</id>
    <published>2019-11-08T13:39:33.000Z</published>
    <updated>2019-11-08T13:47:44.549Z</updated>
    
    <content type="html"><![CDATA[<pre><code>always块间的连接设计</code></pre><h1 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h1><p>在学习过程中发现，always模块的功能除了优先级的概念与一般逻辑有所区别，其他的还是相似度比较高的。更多的区别在于always模块间的逻辑构建。always块之间的逻辑更多的是来自硬件电路的特性，而不是标准的语言逻辑。换言之，在设计always块时只需根据优先级实现相应的功能设计（不包括其他层次的考虑），而在模块间的逻辑设计时必须转化为电路设计逻辑，即组合与时序设计逻辑。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>上次在计数器级联设计中出现了比较具体的问题，这次正好作为例子来展示模块连接的注意事项。具体的功能还是比较简单，就是实现五位计数器（采用级联方式）。<br>三、实验操作<br>！取消了一些系统级设计的步骤，这不是当下考虑的问题。</p><h2 id="1、功能设计"><a href="#1、功能设计" class="headerlink" title="1、功能设计"></a>1、功能设计</h2><p>分别构建个十百千万五个寄存器实现级联进位。<br>每个模块内部为加法循环和进位标志输出。<br>每个模块间以进位标志为信号输出。</p><h2 id="2、功能实现"><a href="#2、功能实现" class="headerlink" title="2、功能实现"></a>2、功能实现</h2><p>！使用数值计算时注意默认的reg型数值是自带正负判断位的，即为signed类型，如果不需要负值计算，需要声明为reg unsigned类型。<br>！注意状态的确定。<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg unsigned [3:0] ge,</span><br><span class="line">output reg unsigned [3:0] shi,</span><br><span class="line">output reg unsigned [3:0] bai,</span><br><span class="line">output reg unsigned [3:0] qian,</span><br><span class="line">output reg unsigned [3:0] wan</span><br><span class="line">);</span><br><span class="line">/*standrd always module</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">;</span><br><span class="line">else </span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">*/</span><br><span class="line">reg ge_ca;  // ge carry bit</span><br><span class="line">reg shi_ca;</span><br><span class="line">reg bai_ca;</span><br><span class="line">reg qian_ca;</span><br><span class="line">//reg wan_ca;</span><br><span class="line">// =&gt;ge =&gt;ge_ca</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">ge &lt;= 4&apos;d0;</span><br><span class="line">else if(ge==4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">ge &lt;= 4&apos;d0;</span><br><span class="line">ge_ca &lt;= 1&apos;b0;</span><br><span class="line">end </span><br><span class="line">else if(ge &lt; 4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">ge &lt;= ge + 4&apos;d1;</span><br><span class="line">if(ge==4&apos;d8)</span><br><span class="line">ge_ca &lt;= 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">// =&gt;shi =&gt;shi_ca</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">shi &lt;=4&apos;d0;</span><br><span class="line">else if(shi==4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">if(ge==4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">shi &lt;= 4&apos;d0;</span><br><span class="line">shi_ca &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">else if(ge==4&apos;d8)</span><br><span class="line">shi_ca &lt;= 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">else if(shi &lt; 4&apos;d9 &amp;&amp; ge_ca == 1&apos;b1)</span><br><span class="line">shi &lt;= shi + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">//=&gt;bai =&gt;bai_ca</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">bai &lt;=4&apos;d0;</span><br><span class="line">else if(bai==4&apos;d9 &amp;&amp; shi==4&apos;d9 )</span><br><span class="line">begin</span><br><span class="line">if(ge==4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">bai &lt;= 4&apos;d0;</span><br><span class="line">bai_ca &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">else if(ge==4&apos;d8)</span><br><span class="line">bai_ca &lt;= 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">else if(bai &lt; 4&apos;d9 &amp;&amp; shi_ca == 1&apos;b1)</span><br><span class="line">bai &lt;= bai + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">//=&gt;qian =&gt;qian_ca</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">qian &lt;=4&apos;d0;</span><br><span class="line">else if(qian==4&apos;d9&amp;&amp;bai==4&apos;d9&amp;&amp;shi==4&apos;d9 )</span><br><span class="line">begin</span><br><span class="line">if( ge==4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">qian &lt;= 4&apos;d0;</span><br><span class="line">qian_ca &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">if(ge==4&apos;d8)</span><br><span class="line">qian_ca &lt;= 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">else if(qian &lt; 4&apos;d9 &amp;&amp; bai_ca == 1&apos;b1)</span><br><span class="line">qian &lt;= qian + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">//=&gt;wan </span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">wan &lt;=4&apos;d0;</span><br><span class="line">else if(wan==4&apos;d9&amp;&amp;qian==4&apos;d9&amp;&amp;bai==4&apos;d9)</span><br><span class="line">begin</span><br><span class="line">if(shi==4&apos;d9 &amp;&amp; ge==4&apos;d9)</span><br><span class="line">wan &lt;= 4&apos;d0;</span><br><span class="line">end</span><br><span class="line">else if(wan &lt; 4&apos;d9 &amp;&amp; qian_ca == 1&apos;b1)</span><br><span class="line">wan &lt;= wan + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/08/always块的级联设计/imag1.png"><h2 id="3、功能仿真"><a href="#3、功能仿真" class="headerlink" title="3、功能仿真"></a>3、功能仿真</h2><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define clk_period 20</span><br><span class="line">module max_tb;</span><br><span class="line">reg Clk=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line"></span><br><span class="line">wire [3:0]ge;</span><br><span class="line">wire [3:0]shi;</span><br><span class="line">wire [3:0]bai;</span><br><span class="line">wire [3:0]qian;</span><br><span class="line">wire [3:0]wan;</span><br><span class="line"></span><br><span class="line">max max_tb_U1(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.ge(ge),</span><br><span class="line">.shi(shi),</span><br><span class="line">.bai(bai),</span><br><span class="line">.qian(qian),</span><br><span class="line">.wan(wan)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always #(`clk_period/2) Clk=~Clk;</span><br><span class="line">initial </span><br><span class="line">begin</span><br><span class="line">#(`clk_period*10)</span><br><span class="line">Rst_n &lt;= 1&apos;b1;</span><br><span class="line">#(`clk_period*110000)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/08/always块的级联设计/imag2.png"><h2 id="4、功能优化"><a href="#4、功能优化" class="headerlink" title="4、功能优化"></a>4、功能优化</h2><p>级联的意义在于可以推广到其他的模块之间，如果只是计数，一个寄存器和一个加法器即可完成工作。当然实际的电路还是利用多个计数器来实现的，只不过机器自动分配资源。</p><h2 id="5、约束条件"><a href="#5、约束条件" class="headerlink" title="5、约束条件"></a>5、约束条件</h2><p>略</p><h2 id="6、时序仿真"><a href="#6、时序仿真" class="headerlink" title="6、时序仿真"></a>6、时序仿真</h2><p>略</p><h2 id="7、时序优化"><a href="#7、时序优化" class="headerlink" title="7、时序优化"></a>7、时序优化</h2><p>略</p><h1 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h1><p>在always语句中的ifelse语句的使用要有明确的时序概念。if中的判断语句对应该时钟沿的前的状态，后面的执行语句代表时钟沿后的状态量。其中if else连续结构代表优先选择权（个人理解为找到符合条件的执行语句执行，而不是符合条件的执行后在去找下一个符合条件的，每个if else结构在一次触发中只会执行一条语句）。这要求在描述时必须由小到大的排列优先级排列以免某些执行语句成为死项（不可能执行到的项），而且这不会语法报错，会浪费时间来排查功能错误。<br>所以，在always中使用优先级赋值时，要先确定每个执行语句的优先级的合理性。<br>这段时间可能都不会做时序约束的部分了。目前主要的任务还是将verilog语法的描述原理逐渐的理解和深入，以达到描述时能够对应相应的硬件电路。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;always块间的连接设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习目标&quot;&gt;&lt;a href=&quot;#一、学习目标&quot; class=&quot;headerlink&quot; title=&quot;一、学习目标&quot;&gt;&lt;/a&gt;一、学习目标&lt;/h1&gt;&lt;p&gt;在学习过程中发现，always模块的功能除了优先级的概念与一般逻辑有所区别，其他的还是相似度比较高的。更多的区别在于always模块间的逻辑构建。always块之间的逻辑更多的是来自硬件电路的特性，而不是标准的语言逻辑。换言之，在设计always块时只需根据优先级实现相应的功能设计（不包括其他层次的考虑），而在模块间的逻辑设计时必须转化为电路设计逻辑，即组合与时序设计逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>计数器级联设计</title>
    <link href="https://github.com/electricdream11/2019/11/07/%E8%AE%A1%E6%95%B0%E5%99%A8%E7%BA%A7%E8%81%94%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/electricdream11/2019/11/07/计数器级联设计/</id>
    <published>2019-11-07T14:09:58.000Z</published>
    <updated>2019-11-07T14:14:11.379Z</updated>
    
    <content type="html"><![CDATA[<pre><code>计数器级联设计</code></pre><h1 id="一、学习目的"><a href="#一、学习目的" class="headerlink" title="一、学习目的"></a>一、学习目的</h1><p>在了解了基本的时序设计流程后，进行必要的训练可以有效地提高时序约束设计的敏感性。在以后的设计过程中，加入时序约束训练是全面设计的重要一步。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>以书籍资料为基础，做好FPGA的时序训练。为接下来的学习做好准备。第一课先巩固理论的时序知识。<br>时钟的响应方法决定了时序的要求。<br>寄存器变量是在时钟边沿进行刷新的，而在实际的过程中，边沿是不严格理想的。这里面有硬件电路的延时，可能导致边沿响应的时间超出了时钟周期。这就导致了设计者必须自行的约束可能出现时序余量不足的地方。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><h2 id="1-系统功能的定义与划分"><a href="#1-系统功能的定义与划分" class="headerlink" title="1.系统功能的定义与划分"></a>1.系统功能的定义与划分</h2><p>作为时序的最佳代表，计数器是时序的最好的说明。所以，可以设计一个五位级联计数器，用于以1个时钟周期间隔的计数操作。</p><h2 id="2-设计规模的初步预算"><a href="#2-设计规模的初步预算" class="headerlink" title="2.设计规模的初步预算"></a>2.设计规模的初步预算</h2><p>五个always语句实现寄存器的时序刷新操作</p><h2 id="3-芯片选型"><a href="#3-芯片选型" class="headerlink" title="3.芯片选型"></a>3.芯片选型</h2><p>MAXII</p><h2 id="4-逻辑模块划分和模块间接口定义（顶层模块设计）"><a href="#4-逻辑模块划分和模块间接口定义（顶层模块设计）" class="headerlink" title="4.逻辑模块划分和模块间接口定义（顶层模块设计）"></a>4.逻辑模块划分和模块间接口定义（顶层模块设计）</h2><p>初步的规划是只用一个模块实现。<br>5.子模块设计<br>由于只有一个模块，就不使用顶层分块设计了。<br>模型设计：<br>在每一个时钟上升沿到来后，寄存器变量改变。<br>对single_cnt而言，初始值为0，第一个有效时钟到来（即复位信号低电平有效转到高电平），这时是异步刷新。为了提高计时的准确性，起步时应使用同步复位信号。<br>对接下来的数据以同步的方式即可将数据级联计数。<br>代码设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">module MAXII(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg [4:0] single_data,</span><br><span class="line">output reg [4:0] ten_data,</span><br><span class="line">output reg [4:0] hundred_data,</span><br><span class="line">output reg [4:0] thousand_data,</span><br><span class="line">output reg [4:0] ten_thousand_data</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg Syn_clr;  // Synchronous sign</span><br><span class="line">always@(posedge Clk)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Syn_clr &lt;= 1&apos;b0;   //there is a time delay</span><br><span class="line">else                  // which is less than one Clk_period</span><br><span class="line">Syn_clr &lt;= 1&apos;b1;   //it can ensure begin scale</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">single_data &lt;= 4&apos;d0; //Asynchronous clear</span><br><span class="line">else if(!Syn_clr)</span><br><span class="line">single_data &lt;= 4&apos;d0; //Synchronous sign begin count</span><br><span class="line">else if(single_data &lt; 4&apos;d9)</span><br><span class="line">single_data &lt;= single_data + 1&apos;b1;</span><br><span class="line">else if(single_data == 4&apos;d9)</span><br><span class="line">single_data &lt;= 4&apos;d0;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">ten_data &lt;= 4&apos;d0;</span><br><span class="line">else if(single_data == 4&apos;d9)</span><br><span class="line">ten_data &lt;= ten_data +1&apos;b1;</span><br><span class="line">else if(ten_data == 4&apos;d9)</span><br><span class="line">ten_data &lt;= 4&apos;d0;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">hundred_data &lt;= 4&apos;d0;</span><br><span class="line">else if(ten_data == 4&apos;d9)</span><br><span class="line">hundred_data &lt;= hundred_data +1&apos;b1;</span><br><span class="line">else if(hundred_data == 4&apos;d9)</span><br><span class="line">hundred_data &lt;= 4&apos;d0;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">thousand_data &lt;= 4&apos;d0;</span><br><span class="line">else if(hundred_data == 4&apos;d9)</span><br><span class="line">thousand_data &lt;= thousand_data +1&apos;b1;</span><br><span class="line">else if(thousand_data == 4&apos;d9)</span><br><span class="line">thousand_data &lt;= 4&apos;d0;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">ten_thousand_data &lt;= 4&apos;d0;</span><br><span class="line">else if(thousand_data == 4&apos;d9)</span><br><span class="line">ten_thousand_data &lt;= ten_data +1&apos;b1;</span><br><span class="line">else if(ten_thousand_data == 4&apos;d9)</span><br><span class="line">ten_thousand_data &lt;= 4&apos;d0;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/07/计数器级联设计/imag1.png"><p>6.功能仿真<br>模型设计：<br>打开使能信号即可，比较简单。<br>代码设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20 // for 50 Mhz</span><br><span class="line"></span><br><span class="line">module MAXII_tb;</span><br><span class="line"></span><br><span class="line">reg Clk=1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line"></span><br><span class="line">wire [4:0] single_data;</span><br><span class="line">wire [4:0] ten_data;</span><br><span class="line">wire [4:0] hundred_data;</span><br><span class="line">wire [4:0] thousand_data;</span><br><span class="line">wire [4:0] ten_thousand_data;</span><br><span class="line">MAXII tb_U1(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.single_data(single_data),</span><br><span class="line">.ten_data(ten_data),</span><br><span class="line">.hundred_data(hundred_data),</span><br><span class="line">.thousand_data(thousand_data),</span><br><span class="line">.ten_thousand_data(ten_thousand_data)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always #(`Clk_period/2)</span><br><span class="line">Clk = ~Clk;</span><br><span class="line">initial</span><br><span class="line">begin</span><br><span class="line"># (`Clk_period *10)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line"># (`Clk_period*11000)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/07/计数器级联设计/imag2.png"><p>7.功能修正<br>！这次的功能失误反应了设计时对所有的情况的考虑不周。这还好，但强行将逻辑语言的设计方法带入到HDL中是十分危险的。在设计初期一定要明确每个变量的变化。<br>！在always块中的ifelse与C中的区别在于always中的条件是满足后就不会向下执行，体现为优先级选择器，而在C中是顺序语句，是依次的执行判断的，为判断语句。这是优先级和顺序的区别。这个习惯要改过来。<br>！目前好像还改不了。后面再改吧。<br>！！！由于学习的时间不足，接下来的问题可能做不了，直接到总结。时序约束的理论知识还没有掌握，可能需要等一段时间才能做后仿真。<br>8.管脚分配<br>8.时序约束<br>9.时序仿真<br>10.综合网表<br>11.板级调试<br>四、实验优化<br>五、实验结果<br>六、总结<br>这次的实验的主要问题还是不熟悉功能与电路间的对应关系。尤其是功能与功能间的衔接问题还是需要不断地熟悉。熟悉的使用并列时序可以在设计是有效减少常识的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;计数器级联设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习目的&quot;&gt;&lt;a href=&quot;#一、学习目的&quot; class=&quot;headerlink&quot; title=&quot;一、学习目的&quot;&gt;&lt;/a&gt;一、学习目的&lt;/h1&gt;&lt;p&gt;在了解了基本的时序设计流程后，进行必要的训练可以有效地提高时序约束设计的敏感性。在以后的设计过程中，加入时序约束训练是全面设计的重要一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>标准化模块设计</title>
    <link href="https://github.com/electricdream11/2019/11/06/%E6%A0%87%E5%87%86%E5%8C%96%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/electricdream11/2019/11/06/标准化模块设计/</id>
    <published>2019-11-06T12:58:07.000Z</published>
    <updated>2019-11-06T13:01:37.925Z</updated>
    
    <content type="html"><![CDATA[<pre><code>标准化模块设计</code></pre><h1 id="一、学习目的"><a href="#一、学习目的" class="headerlink" title="一、学习目的"></a>一、学习目的</h1><p>在掌握了基本的设计方法和操作后，提升的方法无非就是在规模和速度上下功夫。规模需要实际的需求驱动，而速度则是设计的自我追求。更快的设计速度可以提高个人的思考能力和处理复杂模型的能力。而想要提高设计速度，根本的方法还是考虑全面，有章可循。为此，认真的做好每一个标准的模块的设计记录是加速的第一要务。将常见的模块类型加以总结以便以后的利用。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>在设计模块过程中，首先考虑的是输入和输出，而输出是模块的必要条件。至少要有一个输出，这也意味着所有的模块都可以由单输出的模块复合而成。而在设计过程中，输出的多少是实际情况决定的，对其进行分类的意义不大，顶多是功能定义是更加方便，不能提高设计速度。而输入作为输出的控制源，对输入的有效分类可以减少设计过程中出现的输入模糊和输入补充这样的额外工作。还有一个决定设计速度的是控制链的明确。控制链的长短直接决定了设计的难易程度（即always模块的赋值数量，不考虑组合电路的影响）。为了提高实际的设计速度，应当对这两个方面进行分类优化。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><h2 id="1-系统功能的定义与划分"><a href="#1-系统功能的定义与划分" class="headerlink" title="1.系统功能的定义与划分"></a>1.系统功能的定义与划分</h2><p>（1）系统功能的定义<br>构建2个模块，依次为0控制输入X级输出、1控制输入X级输出（之所以为X级是为了在设计时不断地优化）<br>（2）功能划分<br>按照两个模块的输入输出划分即可</p><h2 id="2-设计规模的初步预算"><a href="#2-设计规模的初步预算" class="headerlink" title="2.设计规模的初步预算"></a>2.设计规模的初步预算</h2><p>两个子模块，每个子模块预计6个always模块</p><h2 id="3-芯片选型"><a href="#3-芯片选型" class="headerlink" title="3.芯片选型"></a>3.芯片选型</h2><p>MAX II</p><h2 id="4-逻辑模块划分和模块间接口定义（顶层模块设计）"><a href="#4-逻辑模块划分和模块间接口定义（顶层模块设计）" class="headerlink" title="4.逻辑模块划分和模块间接口定义（顶层模块设计）"></a>4.逻辑模块划分和模块间接口定义（顶层模块设计）</h2><p>实际代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//for getting better design experience</span><br><span class="line">//it needs some standard modules</span><br><span class="line">//just about some usual RTL </span><br><span class="line">`timescale 1ns/1ns</span><br><span class="line"></span><br><span class="line">module standard_m(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input key_a,</span><br><span class="line"></span><br><span class="line">output q</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire q1;</span><br><span class="line">wire q2;</span><br><span class="line">assign q = (q1 &amp;&amp; q2) ||  q2;</span><br><span class="line"></span><br><span class="line">I0LX U1(</span><br><span class="line">.Clk( Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.q1(q1)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">I1LX U2(</span><br><span class="line"></span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.key_a(key_a),</span><br><span class="line"></span><br><span class="line">.q2(q2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="5-子模块设计"><a href="#5-子模块设计" class="headerlink" title="5.子模块设计"></a>5.子模块设计</h2><p>模块1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">module I0LX(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg q1</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//zero user input mean it just controled by </span><br><span class="line">//its own module, usually by time.</span><br><span class="line">//so now it is to muticounter key</span><br><span class="line">reg [3:0] t1_cnt;</span><br><span class="line">reg [3:0] t2_cnt;</span><br><span class="line">reg [3:0] t3_cnt;</span><br><span class="line">reg [3:0] t4_cnt;</span><br><span class="line">reg [3:0] t5_cnt;</span><br><span class="line">//every bit to counter</span><br><span class="line">parameter t1 = 4&apos;d10,</span><br><span class="line"> t2 = 4&apos;d10,</span><br><span class="line"> t3 = 4&apos;d10,</span><br><span class="line"> t4 = 4&apos;d10,</span><br><span class="line"> t5 = 4&apos;d10;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">q1 &lt;= 1&apos;b0;  // no effect</span><br><span class="line">else if(t5_cnt &gt;= t5-1&apos;b1 )</span><br><span class="line">q1 &lt;= ~q1;</span><br><span class="line">else</span><br><span class="line">;            // for other output situation</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">t1_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t1_cnt &gt;= t1)</span><br><span class="line">t1_cnt &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">t1_cnt &lt;= t1_cnt + 1&apos;b1;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">t2_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t2_cnt &gt;= t2)</span><br><span class="line">t2_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t1_cnt == t1)</span><br><span class="line">t2_cnt &lt;= t2_cnt + 1&apos;b1;</span><br><span class="line">else </span><br><span class="line"> ;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">t3_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t3_cnt &gt;= t3)</span><br><span class="line">t3_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t2_cnt == t2)</span><br><span class="line">t3_cnt &lt;= t3_cnt + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">t4_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t4_cnt &gt;= t4)</span><br><span class="line">t4_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t3_cnt == t3)</span><br><span class="line">t4_cnt &lt;= t4_cnt + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">t5_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t5_cnt &gt;= t5-1&apos;b1)</span><br><span class="line">t5_cnt &lt;= 1&apos;b0;</span><br><span class="line">else if( t4_cnt == t4)</span><br><span class="line">t5_cnt &lt;= t5_cnt + 1&apos;b1;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="模块2"><a href="#模块2" class="headerlink" title="模块2"></a>模块2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">module I1LX(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">input key_a,</span><br><span class="line"></span><br><span class="line">output reg q2</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">//one key input is always to set switch,</span><br><span class="line">//and it needs analyse , it is about </span><br><span class="line">// key time</span><br><span class="line">reg key_a_cnt1;</span><br><span class="line">reg key_a_cnt2;</span><br><span class="line">reg [3:0] key_t;</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">q2 &lt;=  1&apos;b0;</span><br><span class="line">else if(key_a_cnt1)</span><br><span class="line">q2 &lt;= 1&apos;b1;</span><br><span class="line">else if(key_a_cnt2)</span><br><span class="line">q2 &lt;= ~q2 ;</span><br><span class="line">else</span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">key_a_cnt1 &lt;= 1&apos;b0;</span><br><span class="line">else if(key_a)</span><br><span class="line">key_a_cnt1 &lt;= 1&apos;b1;</span><br><span class="line">else </span><br><span class="line">   key_a_cnt1 &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">key_a_cnt2 &lt;= 1&apos;b0;</span><br><span class="line">else if(key_a_cnt1)</span><br><span class="line">key_a_cnt2 &lt;= 1&apos;b1;</span><br><span class="line">else if(key_t &gt;= 4&apos;d10)</span><br><span class="line">key_a_cnt2 &lt;= 1&apos;b0;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">key_t &lt;=4&apos;b0;</span><br><span class="line">else if(key_a_cnt2)</span><br><span class="line">key_t &lt;= key_t +1&apos;b1;</span><br><span class="line">else if(!key_a_cnt2)</span><br><span class="line">key_t &lt;= 1&apos;b0;</span><br><span class="line">else </span><br><span class="line">;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="6-功能仿真"><a href="#6-功能仿真" class="headerlink" title="6.功能仿真"></a>6.功能仿真</h2><p>模块1测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20 //simulation to 50 Mhz</span><br><span class="line">module I0LX_tb;</span><br><span class="line">reg Clk  =1&apos;b0;</span><br><span class="line">reg Rst_n=1&apos;b0;</span><br><span class="line">wire q1;</span><br><span class="line"></span><br><span class="line">I0LX U1_tb(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.q1(q1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always#(`Clk_period) </span><br><span class="line">  Clk=~Clk;</span><br><span class="line">initial </span><br><span class="line">begin</span><br><span class="line">#(`Clk_period*10)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`Clk_period*100000000)</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="7-管脚分配"><a href="#7-管脚分配" class="headerlink" title="7.管脚分配"></a>7.管脚分配</h2><p>略</p><h2 id="8-时序约束"><a href="#8-时序约束" class="headerlink" title="8.时序约束"></a>8.时序约束</h2><p>略</p><h2 id="9-时序仿真"><a href="#9-时序仿真" class="headerlink" title="9.时序仿真"></a>9.时序仿真</h2><p>略</p><h2 id="10-综合网表"><a href="#10-综合网表" class="headerlink" title="10.综合网表"></a>10.综合网表</h2><p>略</p><h2 id="11-板级调试"><a href="#11-板级调试" class="headerlink" title="11.板级调试"></a>11.板级调试</h2><p>略</p><h1 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h1><p>时钟上升沿和实时判断的区别导致了时钟计时偏差，解决方法还没找到，这需要实际的设计经历来强化。时序构建和时序约束是数字电路中的重点。</p><h1 id="五、实验优化"><a href="#五、实验优化" class="headerlink" title="五、实验优化"></a>五、实验优化</h1><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>这次主要是对一些常见的简易模块的常用框架熟悉，最后还是要落实到实际的模块的设计。使用自己熟悉的模块架构可以有效地提高设计的稳定性和速度。这是个积累的过程，是不可避免的。此外，开始接触一些其他人的标准模块也是不错的手段。总之，在适应了小规模的verilog设计后，要逐步的接触中等规模的设计，以训练速度和大面积设计的能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;标准化模块设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、学习目的&quot;&gt;&lt;a href=&quot;#一、学习目的&quot; class=&quot;headerlink&quot; title=&quot;一、学习目的&quot;&gt;&lt;/a&gt;一、学习目的&lt;/h1&gt;&lt;p&gt;在掌握了基本的设计方法和操作后，提升的方法无非就是在规模和速度上下功夫。规模需要实际的需求驱动，而速度则是设计的自我追求。更快的设计速度可以提高个人的思考能力和处理复杂模型的能力。而想要提高设计速度，根本的方法还是考虑全面，有章可循。为此，认真的做好每一个标准的模块的设计记录是加速的第一要务。将常见的模块类型加以总结以便以后的利用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>时序约束初试</title>
    <link href="https://github.com/electricdream11/2019/11/04/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E5%88%9D%E8%AF%95/"/>
    <id>https://github.com/electricdream11/2019/11/04/时序约束初试/</id>
    <published>2019-11-04T13:49:06.000Z</published>
    <updated>2019-11-04T13:51:40.606Z</updated>
    
    <content type="html"><![CDATA[<pre><code>设计约束</code></pre><h1 id="一、管脚分配"><a href="#一、管脚分配" class="headerlink" title="一、管脚分配"></a>一、管脚分配</h1><p>将输入输出信号指定到器件的某个管脚，主要是用于实际的连接。</p><a id="more"></a><h1 id="二、时序约束"><a href="#二、时序约束" class="headerlink" title="二、时序约束"></a>二、时序约束</h1><p>生成的qsf文件是所有约束的显示，所有的设置都可以在这里直接修改。还有一些比较方便的约束工具。</p><h1 id="三、实际案例"><a href="#三、实际案例" class="headerlink" title="三、实际案例"></a>三、实际案例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module fit_time(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg beep</span><br><span class="line">);</span><br><span class="line">reg state;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">beep &lt;= 1&apos;b0;</span><br><span class="line">else if(state==1&apos;b1)</span><br><span class="line">beep &lt;= ~beep;</span><br><span class="line">else </span><br><span class="line">beep &lt;= 1&apos;b1;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">state &lt;=1&apos;b0;</span><br><span class="line">else </span><br><span class="line">state &lt;=1&apos;b1;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/11/04/时序约束初试/imag1.png"><img src="/2019/11/04/时序约束初试/imag2.png"><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>基础的时序约束是比较简单的，但在实际的设计中，这个问题是比较难解决的。需要了解许多种类的时序约束的类型，在实际的学习中来具体化。时序分析是比较重要的部分，需要花费时间来消化。最好能够找到时间来学习一下系统的时序约束知识。至少基本的时序约束术语要了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;设计约束&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、管脚分配&quot;&gt;&lt;a href=&quot;#一、管脚分配&quot; class=&quot;headerlink&quot; title=&quot;一、管脚分配&quot;&gt;&lt;/a&gt;一、管脚分配&lt;/h1&gt;&lt;p&gt;将输入输出信号指定到器件的某个管脚，主要是用于实际的连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>失败的尝试</title>
    <link href="https://github.com/electricdream11/2019/11/03/%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <id>https://github.com/electricdream11/2019/11/03/失败的尝试/</id>
    <published>2019-11-03T12:40:30.000Z</published>
    <updated>2019-11-03T14:13:32.077Z</updated>
    
    <content type="html"><![CDATA[<p>复杂状态机的设计</p><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>为了进一步的了解状态机的设计流程，掌握实际的设计规范，能够自由的使用状态机来完成基本的电路设计，特地设计一个比较困难的状态机模型来实践。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>运用状态机的思想完成电子表的所有功能，包括菜单、正常计时、调整时间、设置闹钟、发光等功能。输入为四个按键，输出有数码管、蜂鸣器、led灯等外设。具体的功能参考电子表的功能设计。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><p>注：这里的操作包括所有的设计流程，如功能的确定。</p><h2 id="1-系统功能的定义与划分"><a href="#1-系统功能的定义与划分" class="headerlink" title="1.系统功能的定义与划分"></a>1.系统功能的定义与划分</h2><p>（1）四个按键输入：a_key 、 b_key 、 c_key 、 d_key ；<br>实际分布：</p><img src="/2019/11/03/失败的尝试/imag1.png"><p>（2）数码管输出：[2:0] bit_c  [7:0] numb_c ;<br>（3）蜂鸣器输出:   beep_en;<br>（4）LED输出  ：  led_en;<br>（5）具体功能</p><img src="/2019/11/03/失败的尝试/imag4.png"><img src="/2019/11/03/失败的尝试/imag5.png"><img src="/2019/11/03/失败的尝试/imag6.png"><img src="/2019/11/03/失败的尝试/imag7.png"><p>！对于复杂设计，从输出向输入推导会更轻松。</p><h2 id="2-设计规模的初步预算"><a href="#2-设计规模的初步预算" class="headerlink" title="2.设计规模的初步预算"></a>2.设计规模的初步预算</h2><p>（1）4输入；<br>（2）3+8输出（显示数码管），1输出（蜂鸣器），1输出（LED灯）；</p><h2 id="3-芯片选型"><a href="#3-芯片选型" class="headerlink" title="3.芯片选型"></a>3.芯片选型</h2><p>MAXII</p><h2 id="4-逻辑模块划分和模块间接口定义（顶层模块设计）"><a href="#4-逻辑模块划分和模块间接口定义（顶层模块设计）" class="headerlink" title="4.逻辑模块划分和模块间接口定义（顶层模块设计）"></a>4.逻辑模块划分和模块间接口定义（顶层模块设计）</h2><p>按照输入输出构建顶层模块时，只考虑已知功能即可。<br>模型示意：</p><img src="/2019/11/03/失败的尝试/imag2.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">顶层代码的书写：</span><br><span class="line">input a_key,</span><br><span class="line">input b_key,</span><br><span class="line">input c_key,</span><br><span class="line">input d_key,</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output beep_en,</span><br><span class="line">output led_en,</span><br><span class="line">output [2:0] bit_c,</span><br><span class="line">output [7:0] numb_c</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">state_machine stamac1(</span><br><span class="line">.a_key(a_key),</span><br><span class="line">.b_key(b_key),</span><br><span class="line">.c_key(c_key),</span><br><span class="line">.d_key(d_key),</span><br><span class="line">.Clk  (Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.beep_en(beep_en),</span><br><span class="line">.led_en (led_en),</span><br><span class="line">.bit_c  (bit_c),</span><br><span class="line">.numb_c (numb_c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>5.子模块设计<br>（1）段码转换</p><p>按照a~h的高位到低位对应。这里考虑高位有效数码管。<br>代码展示：</p><img src="/2019/11/03/失败的尝试/imag3.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">digitial_tube_display  dtd_U1(</span><br><span class="line">.Clk(),</span><br><span class="line">.Rst_n(),</span><br><span class="line">.numb(),</span><br><span class="line"></span><br><span class="line">.numb_c(),</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">module digitial_tube_display(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input [3:0] numb,</span><br><span class="line"></span><br><span class="line">output reg [7:0] numb_c</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">numb_c &lt;= 8&apos;b0;</span><br><span class="line">else begin</span><br><span class="line">case(numb)</span><br><span class="line">//number to code of tube</span><br><span class="line">4&apos;b0000: numb_c &lt;=8&apos;b11111100;</span><br><span class="line">4&apos;b0001: numb_c &lt;=8&apos;b01100000;</span><br><span class="line">4&apos;b0010: numb_c &lt;=8&apos;b11011010;</span><br><span class="line">4&apos;b0011: numb_c &lt;=8&apos;b11110010;</span><br><span class="line">4&apos;b0100: numb_c &lt;=8&apos;b01100110;</span><br><span class="line">4&apos;b0101: numb_c &lt;=8&apos;b10110110;</span><br><span class="line">4&apos;b0110: numb_c &lt;=8&apos;b10111110;</span><br><span class="line">4&apos;b0111: numb_c &lt;=8&apos;b11100000;</span><br><span class="line">4&apos;b1000: numb_c &lt;=8&apos;b11111110;</span><br><span class="line">4&apos;b1001: numb_c &lt;=8&apos;b11110110;</span><br><span class="line">//display &quot;-&quot;;</span><br><span class="line">4&apos;b1111: numb_c &lt;=8&apos;b00000010;</span><br><span class="line">         default: numb_c &lt;=8&apos;b0       ;</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line">（2）LED发光</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">led led_U1(</span><br><span class="line">  .led_cr(),</span><br><span class="line">  .Rst_n(),</span><br><span class="line">  </span><br><span class="line">  .led_en()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">module led(</span><br><span class="line">  input led_cr,</span><br><span class="line">  input Rst_n,</span><br><span class="line">  </span><br><span class="line">  output reg led_en</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always@(Rst_n or led_cr)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">led_en &lt;=1&apos;b0;</span><br><span class="line">else if(led_cr)</span><br><span class="line">led_en &lt;=1&apos;b1;</span><br><span class="line">else</span><br><span class="line">led_en &lt;=1&apos;b0;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">（3）蜂鸣器鸣叫</span><br><span class="line">/* module connect</span><br><span class="line">beep beep_U1(</span><br><span class="line">  .beep_cr(),</span><br><span class="line">  .Clk(),</span><br><span class="line">  .Rst_n(),</span><br><span class="line"> </span><br><span class="line">  .reg beep_en()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">module beep(</span><br><span class="line"> input beep_cr,</span><br><span class="line"> input Clk,</span><br><span class="line"> input Rst_n,</span><br><span class="line"> </span><br><span class="line"> output reg beep_en</span><br><span class="line">);</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">beep_en &lt;=1&apos;b1;</span><br><span class="line">else if(beep_cr)</span><br><span class="line">beep_en &lt;= ~beep_en;</span><br><span class="line">else </span><br><span class="line">beep_en &lt;=beep_en;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line">（4）状态机的构建</span><br><span class="line"></span><br><span class="line">module state_machine(</span><br><span class="line">input a_key,</span><br><span class="line">input b_key,</span><br><span class="line">input c_key,</span><br><span class="line">input d_key,</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output reg  led_en,</span><br><span class="line">output reg [4:0] data_h,</span><br><span class="line">output reg [5:0] data_m,</span><br><span class="line">output reg [5:0] data_s</span><br><span class="line">);</span><br><span class="line">//set state signal</span><br><span class="line">parameter S0=2&apos;d0,</span><br><span class="line">          S1=2&apos;d1,</span><br><span class="line">          S2=2&apos;d2,</span><br><span class="line"> S3=2&apos;d3;</span><br><span class="line">//set state flags</span><br><span class="line">reg [1:0] state;</span><br><span class="line">reg [1:0] state_nx;</span><br><span class="line">//set to press all key flags</span><br><span class="line">wire all_key;</span><br><span class="line"></span><br><span class="line">wire led_en_temp;</span><br><span class="line">//realize press all key judge</span><br><span class="line">assign all_key = ~(a_key | b_key | c_key | d_key);</span><br><span class="line">//time save part</span><br><span class="line">reg [4:0] hou_clo;</span><br><span class="line">reg [5:0] min_clo;</span><br><span class="line">reg [5:0] sec_clo;</span><br><span class="line"></span><br><span class="line">reg [4:0] hou_now;</span><br><span class="line">reg [5:0] min_now;</span><br><span class="line">reg [5:0] sec_now;</span><br><span class="line">//here is not like real watch;</span><br><span class="line">reg [4:0] hou_cou;</span><br><span class="line">reg [5:0] min_cou;</span><br><span class="line">reg [5:0] sec_cou;</span><br><span class="line">//connet with counter and clock</span><br><span class="line">reg rcou_bool = 1&apos;b0;</span><br><span class="line">reg bcou_bool = 1&apos;b0;</span><br><span class="line"></span><br><span class="line">reg oclo_bool = 1&apos;b0;</span><br><span class="line">reg aclo_bool = 1&apos;b0;</span><br><span class="line">reg cclo_bool = 1&apos;b0;</span><br><span class="line"></span><br><span class="line">reg anow_bool = 1&apos;b0;</span><br><span class="line">reg cnow_bool = 1&apos;b0;</span><br><span class="line"></span><br><span class="line">led led_U1(</span><br><span class="line">  .led_cr(all_key),</span><br><span class="line">  .Rst_n(Rst_n),</span><br><span class="line">  </span><br><span class="line">  .led_en(led_en_temp)</span><br><span class="line">);</span><br><span class="line">always@(*)begin</span><br><span class="line">led_en&lt;= led_en_temp;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//current state logic</span><br><span class="line">always@(posedge  Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">state &lt;= S0;</span><br><span class="line">else </span><br><span class="line">state &lt;= state_nx;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">//next state logic</span><br><span class="line">always@(state or a_key or b_key or c_key or d_key)begin</span><br><span class="line"></span><br><span class="line">       case(state)</span><br><span class="line">//Do not consider the actual key situation for </span><br><span class="line">//the time being , in fact , it needs eliminaton</span><br><span class="line">//of trembling .</span><br><span class="line">S1:  if((!c_key) &amp; a_key &amp; b_key &amp; d_key)</span><br><span class="line">     state_nx  = S2;</span><br><span class="line">  else if(!c_key &amp; !a_key)</span><br><span class="line">  state_nx  = S0;</span><br><span class="line">S2:  if((!c_key) &amp; a_key &amp; b_key &amp; d_key)</span><br><span class="line">  state_nx  = S3;</span><br><span class="line">  else if(!c_key &amp; !a_key)</span><br><span class="line">  state_nx  = S0;</span><br><span class="line">S3:  if((!c_key) &amp; a_key &amp; b_key &amp; d_key)</span><br><span class="line">     state_nx  = S0;</span><br><span class="line">  else if(!c_key &amp; !a_key)</span><br><span class="line">  state_nx  = S0;</span><br><span class="line">S0:  if((!c_key) &amp; a_key &amp; b_key &amp; d_key)</span><br><span class="line">     state_nx  = S1;</span><br><span class="line">        endcase</span><br><span class="line">end</span><br><span class="line">//function realize</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)begin</span><br><span class="line">/* just to show all time name </span><br><span class="line">       hou_clo &lt;= 5&apos;d0;</span><br><span class="line"> min_clo &lt;= 6&apos;d0;</span><br><span class="line"> sec_clo &lt;= 6&apos;d0;</span><br><span class="line"> </span><br><span class="line"> hou_now &lt;= 5&apos;d0;</span><br><span class="line"> min_now &lt;= 6&apos;d0;</span><br><span class="line"> sec_now &lt;= 6&apos;d0;</span><br><span class="line"> </span><br><span class="line">       hou_cou &lt;= 5&apos;d0;</span><br><span class="line"> min_cou &lt;= 6&apos;d0;</span><br><span class="line"> sec_cou &lt;= 6&apos;d0;</span><br><span class="line">*/ </span><br><span class="line"> data_h &lt;= 5&apos;d0;</span><br><span class="line"> data_m &lt;= 6&apos;d0;</span><br><span class="line"> data_s &lt;= 6&apos;d0;</span><br><span class="line">   </span><br><span class="line">end</span><br><span class="line">else begin</span><br><span class="line">   case(state)</span><br><span class="line">S1: task1;</span><br><span class="line">S2: task2;</span><br><span class="line">S3: task3;</span><br><span class="line">S0: task0;</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//the function to achieve</span><br><span class="line">task task0;</span><br><span class="line">if(!a_key &amp; b_key &amp; c_key &amp; d_key)begin</span><br><span class="line">data_h &lt;= hou_clo;</span><br><span class="line">data_m &lt;= min_clo;</span><br><span class="line">data_s &lt;= sec_clo;</span><br><span class="line">end</span><br><span class="line">else if(!b_key &amp; a_key &amp; c_key &amp; d_key)begin</span><br><span class="line">data_h &lt;= hou_cou;</span><br><span class="line">data_m &lt;= min_cou;</span><br><span class="line">data_s &lt;= sec_cou;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">   else if(!d_key &amp; a_key &amp; c_key &amp; b_key)begin</span><br><span class="line">data_h &lt;= hou_cou;</span><br><span class="line">data_m &lt;= min_cou;</span><br><span class="line">data_s &lt;= sec_cou;</span><br><span class="line">   end      </span><br><span class="line">else  begin</span><br><span class="line">         data_h &lt;= hou_now;</span><br><span class="line">data_m &lt;= min_now;</span><br><span class="line">data_s &lt;= sec_now;</span><br><span class="line">   end</span><br><span class="line">endtask</span><br><span class="line">task task1;</span><br><span class="line">data_h &lt;= hou_cou;</span><br><span class="line">data_m &lt;= min_cou;</span><br><span class="line">data_s &lt;= sec_cou;   </span><br><span class="line">if(!a_key &amp; b_key &amp; c_key &amp; d_key)</span><br><span class="line">      rcou_bool &lt;=1&apos;b1;</span><br><span class="line">else if(!b_key &amp; a_key &amp; c_key &amp; d_key)</span><br><span class="line">      bcou_bool &lt;=1&apos;b1;</span><br><span class="line">   else if(!d_key &amp; a_key &amp; c_key &amp; b_key)</span><br><span class="line">      bcou_bool &lt;=1&apos;b0;</span><br><span class="line">else  </span><br><span class="line">         rcou_bool &lt;=1&apos;b0;</span><br><span class="line">endtask</span><br><span class="line">task task2;</span><br><span class="line">         data_h &lt;= hou_clo;</span><br><span class="line">data_m &lt;= min_clo;</span><br><span class="line">data_s &lt;= sec_clo;</span><br><span class="line">if(!a_key &amp; b_key &amp; c_key &amp; d_key)</span><br><span class="line">      oclo_bool &lt;= ~oclo_bool;</span><br><span class="line">else if(!b_key &amp; a_key &amp; c_key &amp; d_key)</span><br><span class="line">      aclo_bool &lt;= 1&apos;b1;</span><br><span class="line">   else if(!d_key &amp; a_key &amp; c_key &amp; b_key)</span><br><span class="line">      cclo_bool &lt;= 1&apos;b1;</span><br><span class="line">else  begin</span><br><span class="line">      aclo_bool &lt;= 1&apos;b0;</span><br><span class="line">cclo_bool &lt;= 1&apos;b0;</span><br><span class="line">end</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">endtask</span><br><span class="line">task task3;</span><br><span class="line">if(!a_key &amp; b_key &amp; c_key &amp; d_key)begin</span><br><span class="line">           ;</span><br><span class="line">end</span><br><span class="line">else if(!b_key &amp; a_key &amp; c_key &amp; d_key)</span><br><span class="line">    anow_bool &lt;=1&apos;b1;</span><br><span class="line">   else if(!d_key &amp; a_key &amp; c_key &amp; b_key)</span><br><span class="line">    cnow_bool &lt;=1&apos;b1;</span><br><span class="line">else  begin</span><br><span class="line">    anow_bool &lt;=1&apos;b0;</span><br><span class="line"> cnow_bool &lt;=1&apos;b0;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br><span class="line"></span><br><span class="line">（5）晶体管的动态显示</span><br><span class="line">代码显示：</span><br><span class="line">module digitial_tube_eight_show(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input [4:0] data_h,</span><br><span class="line">input [5:0] data_m,</span><br><span class="line">input [5:0] data_s,</span><br><span class="line"></span><br><span class="line">output reg [2:0] bit_c,</span><br><span class="line">output reg [7:0] numb_c</span><br><span class="line">);</span><br><span class="line">reg [3:0] data_h_sd;  // single digits</span><br><span class="line">reg [3:0] data_h_td;  // ten digits</span><br><span class="line">reg [3:0] data_m_sd;</span><br><span class="line">reg [3:0] data_m_td;</span><br><span class="line">reg [3:0] data_s_sd;</span><br><span class="line">reg [3:0] data_s_td;</span><br><span class="line"></span><br><span class="line">wire [7:0] numb1;</span><br><span class="line">wire [7:0] numb2;</span><br><span class="line">wire [7:0] numb3;</span><br><span class="line">wire [7:0] numb4;</span><br><span class="line">wire [7:0] numb5;</span><br><span class="line">wire [7:0] numb6;</span><br><span class="line"></span><br><span class="line">digitial_tube_display  dtd_U1(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.numb(data_h_td),</span><br><span class="line"></span><br><span class="line">.numb_c(numb1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">digitial_tube_display  dtd_U2(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.numb(data_h_sd),</span><br><span class="line"></span><br><span class="line">.numb_c(numb2)</span><br><span class="line">);</span><br><span class="line">digitial_tube_display  dtd_U3(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.numb(data_m_td),</span><br><span class="line"></span><br><span class="line">.numb_c(numb3)</span><br><span class="line">);</span><br><span class="line">digitial_tube_display  dtd_U4(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.numb(data_m_sd),</span><br><span class="line"></span><br><span class="line">.numb_c(numb4)</span><br><span class="line">);</span><br><span class="line">digitial_tube_display  dtd_U5(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.numb(data_s_td),</span><br><span class="line"></span><br><span class="line">.numb_c(numb5)</span><br><span class="line">);</span><br><span class="line">digitial_tube_display  dtd_U6(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.numb(data_s_sd),</span><br><span class="line"></span><br><span class="line">.numb_c(numb6)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">bit_c &lt;= 3&apos;b0;</span><br><span class="line">else if(bit_c == 3&apos;d7)</span><br><span class="line">bit_c &lt;= 3&apos;b0;</span><br><span class="line">else </span><br><span class="line">bit_c &lt;= bit_c +1&apos;b1;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">  numb_c &lt;= 8&apos;b0;</span><br><span class="line">else begin</span><br><span class="line">      case(bit_c)</span><br><span class="line">       3&apos;d0:  numb_c &lt;=numb1;</span><br><span class="line">       3&apos;d1:  numb_c &lt;=numb2;</span><br><span class="line">       3&apos;d2:  numb_c &lt;=8&apos;b00000010;</span><br><span class="line">       3&apos;d3:  numb_c &lt;=numb3;</span><br><span class="line">       3&apos;d4:  numb_c &lt;=numb4;</span><br><span class="line">       3&apos;d5:  numb_c &lt;=8&apos;b00000010;</span><br><span class="line">       3&apos;d6:  numb_c &lt;=numb5;</span><br><span class="line">       3&apos;d7:  numb_c &lt;=numb6;</span><br><span class="line">     endcase</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)begin</span><br><span class="line">data_h_sd &lt;= 4&apos;b0;</span><br><span class="line">data_h_td &lt;= 4&apos;b0;</span><br><span class="line">data_m_sd &lt;= 4&apos;b0;</span><br><span class="line">data_m_td &lt;= 4&apos;b0;</span><br><span class="line">data_s_sd &lt;= 4&apos;b0;</span><br><span class="line">data_s_td &lt;= 4&apos;b0;</span><br><span class="line">end</span><br><span class="line">else begin</span><br><span class="line">data_h_sd &lt;= data_h % 4&apos;d10;</span><br><span class="line">data_h_td &lt;= (data_h - data_h % 4&apos;d10)/4&apos;d10;</span><br><span class="line">data_m_sd &lt;= data_m % 4&apos;d10;</span><br><span class="line">data_m_td &lt;= (data_m - data_m % 4&apos;d10)/4&apos;d10;</span><br><span class="line">data_s_sd &lt;= data_s % 4&apos;d10;</span><br><span class="line">data_s_td &lt;= (data_s - data_s % 6&apos;d10)/4&apos;d10;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>（6）中间模型构建<br>一、闹钟模块</p><p>二、计时模块<br>三、主显示模块</p><p>6.功能仿真<br>7.管脚分配<br>8.时序约束<br>9.时序仿真<br>10.综合网表<br>11.板级调试<br>四、实验现象<br>五、实验优化<br>六、实验结果</p><h1 id="七、实验总结"><a href="#七、实验总结" class="headerlink" title="七、实验总结"></a>七、实验总结</h1><p>由于时间关系，这次的设计并没有完成，只是在功能级的层面上进行了尝试，而且还没有做完。这次的尝试最大的收获就是了解了模块划分的重要性。化整为零是在大型项目中最为重要的思想。一次性的设计一个大型的模块是不理智的。在将近五天的时间内，连最简单的一步都没有走完。虽然半途而废是比较遗憾的，但掌握科学的方法是更为重要的，所以接下来就先终止这次的尝试，先从一些比较小的项目入手。<br>等以后学习的内容达到了要求后再来尝试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复杂状态机的设计&lt;/p&gt;
&lt;h1 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h1&gt;&lt;p&gt;为了进一步的了解状态机的设计流程，掌握实际的设计规范，能够自由的使用状态机来完成基本的电路设计，特地设计一个比较困难的状态机模型来实践。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>always模块中的几个小问题</title>
    <link href="https://github.com/electricdream11/2019/10/29/always%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/electricdream11/2019/10/29/always模块中的几个小问题/</id>
    <published>2019-10-29T14:53:25.000Z</published>
    <updated>2019-10-29T14:59:52.525Z</updated>
    
    <content type="html"><![CDATA[<pre><code>关于always模块的几个语法问题</code></pre><h1 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h1><p>always模块中的逻辑设计和高级语言十分的类似，可以依次的执行。但是，作为初学者，往往会忽略always块中的并行电路特性而导致错误。所有，了解always块的综合原理是必要的。</p><a id="more"></a><h1 id="2、always块的综合原理"><a href="#2、always块的综合原理" class="headerlink" title="2、always块的综合原理"></a>2、always块的综合原理</h1><p>（1）verilog代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input a_in,</span><br><span class="line"></span><br><span class="line">output reg a_out</span><br><span class="line">);</span><br><span class="line">reg a_sign ;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">a_out &lt;= 1&apos;b0;</span><br><span class="line">else if(a_in == 1&apos;b0)</span><br><span class="line">a_out &lt;= 1&apos;b1;</span><br><span class="line">else if(a_in == 1&apos;b1)</span><br><span class="line">a_sign &lt;= 1&apos;b0;</span><br><span class="line">   else if(a_in == 1&apos;b0)</span><br><span class="line">a_sign &lt;= 1&apos;b1;</span><br><span class="line">else if(a_sign == 1&apos;b0)</span><br><span class="line">a_out &lt;=1&apos;b0;</span><br><span class="line">else</span><br><span class="line">a_out &lt;=1&apos;b1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>（2）电路模型</p><img src="/2019/10/29/always模块中的几个小问题/imag1.png"><p>这是一个简单的alway优先级模块。<br>可以看出在中间数据a_sign没有综合为寄存器。<br>（3）将中间reg类型变量a_sign展宽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input a_in,</span><br><span class="line"></span><br><span class="line">output reg a_out</span><br><span class="line">);</span><br><span class="line">reg [2:0] a_sign ;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">a_out &lt;= 1&apos;b0;</span><br><span class="line">else if(a_in == 1&apos;b0)</span><br><span class="line">a_out &lt;= 1&apos;b1;</span><br><span class="line">else if(a_in == 1&apos;b1)</span><br><span class="line">a_sign &lt;= 2&apos;b00;</span><br><span class="line">   else if(a_in == 1&apos;b0)</span><br><span class="line">a_sign &lt;= 2&apos;b10;</span><br><span class="line">else if(a_sign == 2&apos;b10)</span><br><span class="line">a_out &lt;=1&apos;b0;</span><br><span class="line">else</span><br><span class="line">a_out &lt;=1&apos;b1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/29/always模块中的几个小问题/imag2.png"><img src="/2019/10/29/always模块中的几个小问题/imag3.png"><p>可以看到a_sign被综合为状态机的状态量了。换言之，always模块对具有判断性质的reg型变量的处理方法就是转化为状态机来实现顺序的执行。<br>（4）对比一下case的执行方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input a_in,</span><br><span class="line"></span><br><span class="line">output reg a_out</span><br><span class="line">);</span><br><span class="line">reg [2:0] a_sign ;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">a_out &lt;= 1&apos;b0;</span><br><span class="line">else if(a_in == 1&apos;b0)</span><br><span class="line">a_out &lt;= 1&apos;b1;</span><br><span class="line">else if(a_in == 1&apos;b1)</span><br><span class="line">a_sign &lt;= 2&apos;b00;</span><br><span class="line">   else if(a_in == 1&apos;b0)</span><br><span class="line">a_sign &lt;= 2&apos;b10;</span><br><span class="line">/*</span><br><span class="line">else if(a_sign == 2&apos;b10)</span><br><span class="line">a_out &lt;=1&apos;b0;</span><br><span class="line">else</span><br><span class="line">a_out &lt;=1&apos;b1;</span><br><span class="line">*/</span><br><span class="line">   else </span><br><span class="line">  begin</span><br><span class="line">case(a_sign)</span><br><span class="line">2&apos;b10   :  a_out &lt;=1&apos;b0; </span><br><span class="line">2&apos;b11   :  a_out &lt;=1&apos;b1;</span><br><span class="line">default :  a_out &lt;=1&apos;b1;</span><br><span class="line">endcase</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>实际的结果和前面的ifelse的执行方式是一样的。换言之对于中间变量一旦被作为条件变量使用，执行的方式就会转化为状态机，这时ifelse和case语句是等价的。<br>（5）条件变量的约束<br>条件变量被优先级约束了，即不能在其他的模块进行赋值操作（优先级不允许）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input a_in,</span><br><span class="line"></span><br><span class="line">output reg a_out</span><br><span class="line">);</span><br><span class="line">reg [2:0] a_sign ;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">a_sign &lt;= 1&apos;b1;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">a_out &lt;= 1&apos;b0;</span><br><span class="line">else if(a_in == 1&apos;b0)</span><br><span class="line">a_out &lt;= 1&apos;b1;</span><br><span class="line">else if(a_in == 1&apos;b1)</span><br><span class="line">a_sign &lt;= 2&apos;b00;</span><br><span class="line">   else if(a_in == 1&apos;b0)</span><br><span class="line">a_sign &lt;= 2&apos;b10;</span><br><span class="line">/*</span><br><span class="line">else if(a_sign == 2&apos;b10)</span><br><span class="line">a_out &lt;=1&apos;b0;</span><br><span class="line">else</span><br><span class="line">a_out &lt;=1&apos;b1;</span><br><span class="line">*/</span><br><span class="line">   else </span><br><span class="line">  begin</span><br><span class="line">case(a_sign)</span><br><span class="line">2&apos;b10   :  a_out &lt;=1&apos;b0; </span><br><span class="line">2&apos;b11   :  a_out &lt;=1&apos;b1;</span><br><span class="line">default :  a_out &lt;=1&apos;b1;</span><br><span class="line">endcase</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error (10028): Can&apos;t resolve multiple constant drivers for net &quot;a_sign.000&quot; at max.v(15)</span><br><span class="line">Error (10029): Constant driver at max.v(9)</span><br><span class="line">Error (10028): Can&apos;t resolve multiple constant drivers for net &quot;a_sign.001&quot; at max.v(15)</span><br><span class="line">Error (10028): Can&apos;t resolve multiple constant drivers for net &quot;a_sign.010&quot; at max.v(15)</span><br><span class="line">Error (10028): Can&apos;t resolve multiple constant drivers for net &quot;a_sign.011&quot; at max.v(15)</span><br><span class="line">Error (12153): Can&apos;t elaborate top-level user hierarchy</span><br><span class="line">Error: Quartus Prime Analysis &amp; Elaboration was unsuccessful. 6 errors, 1 warning</span><br><span class="line">Error: Peak virtual memory: 4716 megabytes</span><br><span class="line">Error: Processing ended: Tue Oct 29 22:04:18 2019</span><br><span class="line">Error: Elapsed time: 00:00:22</span><br><span class="line">Error: Total CPU time (on all processors): 00:00:51</span><br></pre></td></tr></table></figure><p>从结果可以看到这种对条件变量的赋值是不符合优先级的要求的。<br>（6）always模块间的要求<br>保证模块间的唯一性的功能，不能有重复功能代码，这也是不能按照逻辑语言的设计思路的一个方面。<br>模块中与输入输出构成不了路径的变量将不被综合。<br>（7）always中的基本设计思想<br>always模块中的设计思想就是构建一条路径，使输入能够控制输出。所有不能够达到这一目的的路径都将忽略。这是基于逻辑的自动优化。</p><h1 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h1><p>使用always模块时要注意优先级和唯一性。即执行的顺序是并行还是顺序。变量是否具有唯一性则代表是否受单一控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;关于always模块的几个语法问题&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/a&gt;1、问题描述&lt;/h1&gt;&lt;p&gt;always模块中的逻辑设计和高级语言十分的类似，可以依次的执行。但是，作为初学者，往往会忽略always块中的并行电路特性而导致错误。所有，了解always块的综合原理是必要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="verilog" scheme="https://github.com/electricdream11/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>按键消抖</title>
    <link href="https://github.com/electricdream11/2019/10/29/%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96/"/>
    <id>https://github.com/electricdream11/2019/10/29/按键消抖/</id>
    <published>2019-10-29T12:04:58.000Z</published>
    <updated>2019-10-29T12:15:17.039Z</updated>
    
    <content type="html"><![CDATA[<pre><code>按键延时消抖实验</code></pre><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>通过对按键消抖的过程设计，了解FPGA内部的条件的控制的方式。通过组合受控模块来了解模块间的组合设计的过程。主要还是对延时控制的掌握。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>通过延时来实现对数据采集的有效性的纠正。此外，还要考虑模块间的连接问题。原理还是简单的。</p><h1 id="三、实际操作"><a href="#三、实际操作" class="headerlink" title="三、实际操作"></a>三、实际操作</h1><h2 id="1-系统功能的定义与划分"><a href="#1-系统功能的定义与划分" class="headerlink" title="1.系统功能的定义与划分"></a>1.系统功能的定义与划分</h2><p>（1）消抖按键模块<br>（2）蜂鸣器模块<br>（3）顶层连接模块</p><h2 id="2-设计规模的初步预算"><a href="#2-设计规模的初步预算" class="headerlink" title="2.设计规模的初步预算"></a>2.设计规模的初步预算</h2><p>有一个2ms定时器，一个20ms定时器，按键状态转化器，蜂鸣器工作模块。</p><h2 id="3-芯片选型"><a href="#3-芯片选型" class="headerlink" title="3.芯片选型"></a>3.芯片选型</h2><p>MAXII</p><h2 id="4-逻辑模块划分和模块间接口定义（顶层模块设计）"><a href="#4-逻辑模块划分和模块间接口定义（顶层模块设计）" class="headerlink" title="4.逻辑模块划分和模块间接口定义（顶层模块设计）"></a>4.逻辑模块划分和模块间接口定义（顶层模块设计）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">module max(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input key,</span><br><span class="line"></span><br><span class="line">output beep</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire key_cnt;</span><br><span class="line"></span><br><span class="line">key key_U1(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">   .Rst_n(Rst_n),</span><br><span class="line">   .key(key),</span><br><span class="line">   </span><br><span class="line">.key_cnt(key_cnt)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beep beep_U2(</span><br><span class="line">.Clk(Clk),</span><br><span class="line">   .Rst_n(Rst_n),</span><br><span class="line">.key_cnt(key_cnt),</span><br><span class="line"></span><br><span class="line">   .beep(beep)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/29/按键消抖/imag1.png"><h2 id="5-子模块设计"><a href="#5-子模块设计" class="headerlink" title="5.子模块设计"></a>5.子模块设计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">module key(</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line">input key,</span><br><span class="line"></span><br><span class="line">output reg key_cnt</span><br><span class="line">);</span><br><span class="line">reg  key_reg ;</span><br><span class="line">reg  [19:0] time_cnt;</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">   if(!Rst_n)</span><br><span class="line">key_cnt &lt;=1&apos;b1;</span><br><span class="line">else if(time_cnt ==20&apos;b1)</span><br><span class="line">key_cnt &lt;= key;</span><br><span class="line">else</span><br><span class="line">key_cnt &lt;=1&apos;b1;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)</span><br><span class="line">begin</span><br><span class="line">if(!Rst_n)begin</span><br><span class="line">key_reg  &lt;=1&apos;b1;</span><br><span class="line">time_cnt &lt;= 20&apos;b0;</span><br><span class="line">end</span><br><span class="line">else  begin</span><br><span class="line">         key_reg &lt;= key;</span><br><span class="line">        if (key != key_reg)</span><br><span class="line">         time_cnt &lt;= 20&apos;d1000_000;</span><br><span class="line">        else begin</span><br><span class="line">        if(time_cnt &gt;20&apos;b0)</span><br><span class="line">     time_cnt &lt;= time_cnt - 1&apos;b1;</span><br><span class="line">  else </span><br><span class="line">     time_cnt &lt;= 20&apos;b0;</span><br><span class="line">             end</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/29/按键消抖/imag2.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module beep(</span><br><span class="line">    input Clk,</span><br><span class="line"> input Rst_n,</span><br><span class="line"> input key_cnt,</span><br><span class="line"> </span><br><span class="line"> output reg beep</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">beep &lt;=1&apos;b1;</span><br><span class="line">else if(!key_cnt)</span><br><span class="line">beep &lt;= ~ beep;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/29/按键消抖/imag3.png"><p>！小总结<br>在描述语言中，要时刻注意reg型变量的连续赋值的条件。使用reg型变量判断时不能与敏感源重叠。</p><h2 id="6-功能仿真"><a href="#6-功能仿真" class="headerlink" title="6.功能仿真"></a>6.功能仿真</h2><p>测试脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define Clk_period 20</span><br><span class="line">module max_tb;</span><br><span class="line"></span><br><span class="line">reg Clk;</span><br><span class="line">reg Rst_n;</span><br><span class="line">reg key;</span><br><span class="line"></span><br><span class="line">wire beep;</span><br><span class="line">max max_U(</span><br><span class="line">   .Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line">.key(key),</span><br><span class="line"></span><br><span class="line">.beep(beep)</span><br><span class="line">);</span><br><span class="line">initial Clk = 1&apos;b0;</span><br><span class="line"></span><br><span class="line">always#(`Clk_period/2) Clk = ~ Clk;</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">Rst_n=1&apos;b0;</span><br><span class="line">key  =1&apos;b1;</span><br><span class="line">#(`Clk_period/2)</span><br><span class="line">Rst_n=1&apos;b1;</span><br><span class="line">#(`Clk_period/2)</span><br><span class="line">key  =1&apos;b0;</span><br><span class="line">#(`Clk_period/2)</span><br><span class="line">key  =1&apos;b1;</span><br><span class="line">#(`Clk_period*100)</span><br><span class="line">   key  =1&apos;b0;</span><br><span class="line">#(`Clk_period/2)</span><br><span class="line">key  =1&apos;b1;</span><br><span class="line">#(`Clk_period*100)</span><br><span class="line">key  =1&apos;b0;</span><br><span class="line">#(`Clk_period*1000)</span><br><span class="line">key  =1&apos;b1;</span><br><span class="line">#(`Clk_period*1000000)</span><br><span class="line">key  =1&apos;b0;</span><br><span class="line">#(`Clk_period*100000000)</span><br><span class="line">key  =1&apos;b1;</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>结果显示</p><img src="/2019/10/29/按键消抖/imag4.png"><h2 id="7-管脚分配"><a href="#7-管脚分配" class="headerlink" title="7.管脚分配"></a>7.管脚分配</h2><img src="/2019/10/29/按键消抖/imag5.png"><h2 id="8-时序约束"><a href="#8-时序约束" class="headerlink" title="8.时序约束"></a>8.时序约束</h2><p>额，软件改版了，找不到设置的方式了，只能等以后再弄。</p><h2 id="9-时序仿真"><a href="#9-时序仿真" class="headerlink" title="9.时序仿真"></a>9.时序仿真</h2><p>略</p><h2 id="10-综合网表"><a href="#10-综合网表" class="headerlink" title="10.综合网表"></a>10.综合网表</h2><p>略</p><h2 id="11-板级调试"><a href="#11-板级调试" class="headerlink" title="11.板级调试"></a>11.板级调试</h2><p>略</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>功能层次的设计还是要不断地写下去，至少要对所有的基本的设计结构都有比较熟悉的理解。后面的步骤尽快的完善，最好能够全部做一遍，这样才能为下一步的学习做好准备。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;按键延时消抖实验&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h1&gt;&lt;p&gt;通过对按键消抖的过程设计，了解FPGA内部的条件的控制的方式。通过组合受控模块来了解模块间的组合设计的过程。主要还是对延时控制的掌握。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>时序约束与时序分析基础</title>
    <link href="https://github.com/electricdream11/2019/10/28/%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F%E4%B8%8E%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/electricdream11/2019/10/28/时序约束与时序分析基础/</id>
    <published>2019-10-28T10:11:49.000Z</published>
    <updated>2019-10-28T10:16:34.660Z</updated>
    
    <content type="html"><![CDATA[<pre><code>时序约束与时序分析</code></pre><h1 id="一、时序约束与时序分析基础"><a href="#一、时序约束与时序分析基础" class="headerlink" title="一、时序约束与时序分析基础"></a>一、时序约束与时序分析基础</h1><h2 id="1-时序约束的说明"><a href="#1-时序约束的说明" class="headerlink" title="1.时序约束的说明"></a>1.时序约束的说明</h2><p>设计中常用的约束（Assignment or Constraints）主要有时序约束、区域约束和位置约束。还有一些不常见的约束。<br>时序约束的主要的作用是提高设计的工作频率和获得正确的时序分析报告。<br>时序约束的方式有静态约束（STA）和动态时序约束，区别在于STA只关注时序性能，不考虑其他逻辑因素。</p><a id="more"></a><h2 id="2-周期与最高频率"><a href="#2-周期与最高频率" class="headerlink" title="2.周期与最高频率"></a>2.周期与最高频率</h2><p>（1）最小时钟周期t_CLK=Microt_CO + t_LOGIC + t_NET +Microt_su - t_CLK-SKEW; 其中右式的物理含义依次是“寄存器固有的时钟输出延时”、“同步元件之间的组合逻辑延迟”、“网线延迟”、“寄存器固有的时钟建立时间”、“时钟偏斜”。具体的含义在以后的学习中会有介绍。<br>（2）最高频率f_max<br>f_max=1/t_CLK;是衡量运行速度的关键参数。</p><h2 id="3-利用Quarteus-II工具分析设计"><a href="#3-利用Quarteus-II工具分析设计" class="headerlink" title="3.利用Quarteus II工具分析设计"></a>3.利用Quarteus II工具分析设计</h2><p>在时序分析报告中可以查看f_max。也可以查看每个路径的f_max以便分类设计约束。<br>在编译过程中的info中也可以找到延时的大小和路径。<br>还有一些其他视图下的观察方法就不一一介绍了。</p><h2 id="4-时钟建立时间"><a href="#4-时钟建立时间" class="headerlink" title="4.时钟建立时间"></a>4.时钟建立时间</h2><p>时钟建立时间（Clock Setup Time）常用t_su表示，代表时钟到达前，数据和使能信号已经准备好的最小时间间隔。<br>t_su = Data Delay - Clock Delay + Microt_su;<br>即时钟建立时间等于数据延迟加上寄存器延时减掉时钟延迟。</p><h2 id="5-时钟保持时间t-H-Clock-Hold-Time"><a href="#5-时钟保持时间t-H-Clock-Hold-Time" class="headerlink" title="5.时钟保持时间t_H(Clock Hold Time)"></a>5.时钟保持时间t_H(Clock Hold Time)</h2><p>t_H= Clock Delay -Data Delay + Microt_H;<br>即时钟保持时间等于时钟延迟加上寄存器保持时间减掉数据延时</p><h2 id="6-时钟输出延时t-CO-Clock-to-output-Time"><a href="#6-时钟输出延时t-CO-Clock-to-output-Time" class="headerlink" title="6.时钟输出延时t_CO(Clock to output Time)"></a>6.时钟输出延时t_CO(Clock to output Time)</h2><p>t_TO=Clock Delay + Data Delay + Microt_CO<br>其中Microt_CO为寄存器相应时钟有效沿将数据送到输出口的延时。</p><h2 id="7-引脚到引脚的延时t-PD-Pin-to-Pin-Delay"><a href="#7-引脚到引脚的延时t-PD-Pin-to-Pin-Delay" class="headerlink" title="7.引脚到引脚的延时t_PD(Pin to Pin Delay)"></a>7.引脚到引脚的延时t_PD(Pin to Pin Delay)</h2><p>CPLD的布线矩阵长度固定，t_PD可以标志CPLD的速度等级</p><h2 id="8-Slack（是否满足时序的称谓）"><a href="#8-Slack（是否满足时序的称谓）" class="headerlink" title="8.Slack（是否满足时序的称谓）"></a>8.Slack（是否满足时序的称谓）</h2><p>Slack为正，则时序余量充足；Slack为负，时序余量不足。<br>其中保持时间Slack（Hold Time Slack）用于衡量数据稳定采样的最小保持时间是否满足。</p><h2 id="9-时钟偏斜（Clock-Skew）"><a href="#9-时钟偏斜（Clock-Skew）" class="headerlink" title="9.时钟偏斜（Clock Skew）"></a>9.时钟偏斜（Clock Skew）</h2><p>由于不同路径的不同延时长度导致的时钟沿偏差。</p><h2 id="10-quartus-II-中的优化工具"><a href="#10-quartus-II-中的优化工具" class="headerlink" title="10.quartus II 中的优化工具"></a>10.quartus II 中的优化工具</h2><p>使用Timing Analyzer Tool可以指定分析某条路径上的时序延时。</p><h1 id="二、设置时序约束的常用方法"><a href="#二、设置时序约束的常用方法" class="headerlink" title="二、设置时序约束的常用方法"></a>二、设置时序约束的常用方法</h1><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h2><p>总的设计方法有三种：<br>（1）【assignments】/【Timing Settings】<br>（2）【assignments】/【Wizards】/【Timing Wizard】<br>（3）【assignments】/【Assignment Editor】<br>当然，也可以对总的约束文件QSF修改来实现。</p><h2 id="2-指定全局时序约束"><a href="#2-指定全局时序约束" class="headerlink" title="2.指定全局时序约束"></a>2.指定全局时序约束</h2><h3 id="（1）时序驱动的编译（TDC）"><a href="#（1）时序驱动的编译（TDC）" class="headerlink" title="（1）时序驱动的编译（TDC）"></a>（1）时序驱动的编译（TDC）</h3><p>在Fitter Setting 中设置为时序驱动的编译<br>具体的优化内容包括时序、保持时间、IO单元寄存器的放置。<br>也可以设置优化所有的路径或其他路径，具体的自己体会。</p><h3 id="（2）全局时钟设置"><a href="#（2）全局时钟设置" class="headerlink" title="（2）全局时钟设置"></a>（2）全局时钟设置</h3><p>全局时钟可以实现所有时钟信号同频，是比较理想的时钟源。<br>在【Assignments】/【Timing Settings】中即可设置全局时钟。</p><h3 id="（3）全局的IO时序设置"><a href="#（3）全局的IO时序设置" class="headerlink" title="（3）全局的IO时序设置"></a>（3）全局的IO时序设置</h3><p>在【Assignments】/【Timing Settings】可以设置全局IO时序</p><h3 id="（4）时序分析和报告选项"><a href="#（4）时序分析和报告选项" class="headerlink" title="（4）时序分析和报告选项"></a>（4）时序分析和报告选项</h3><p>在时序分析约束界面可以选择报告的路径数和时序要求。</p><h3 id="（5）时序向导（Timing-Wizard）"><a href="#（5）时序向导（Timing-Wizard）" class="headerlink" title="（5）时序向导（Timing Wizard）"></a>（5）时序向导（Timing Wizard）</h3><p>在【Assignments】/【Wizards】/【Timing Wizard】即可依次进行以上的选项。</p><h2 id="3-指定个别的时钟约束"><a href="#3-指定个别的时钟约束" class="headerlink" title="3.指定个别的时钟约束"></a>3.指定个别的时钟约束</h2><h3 id="（1）工具"><a href="#（1）工具" class="headerlink" title="（1）工具"></a>（1）工具</h3><p>使用【Assignment Editor】对individual（单个）实现时序约束</p><h3 id="（2）指定个别时钟要求"><a href="#（2）指定个别时钟要求" class="headerlink" title="（2）指定个别时钟要求"></a>（2）指定个别时钟要求</h3><p>Altera中的时钟有独立时钟（absolute clock）和衍生时钟（derived clock）。前者独立于其他时钟，后者为某个absolute clock衍生出的时钟，说明相位差、分频或倍频比等参数。<br>创建衍生时钟只需在独立时钟的基础上修改即可。</p><h3 id="（3）个别时序约束"><a href="#（3）个别时序约束" class="headerlink" title="（3）个别时序约束"></a>（3）个别时序约束</h3><p>具体的设计方法有两种：在创建时对应物理节点或在【assignment editor】中根据所需的参数进行设计。具体要考虑的参数比较多，就不深入的分析，在用到时再逐个分析。</p><h3 id="（4）时序约束的种类"><a href="#（4）时序约束的种类" class="headerlink" title="（4）时序约束的种类"></a>（4）时序约束的种类</h3><p>主要有单点、点到点、通配符和时序分组这几种方式。<br>·单点（Single-Point）<br>对某个点的约束将影响所有和这个点有关的路径<br>形式为to Y<br>·点到点（Point to Point）<br>只对两点之间的路径有效。<br>形式为from X to Y<br>·通配符 （Wildcard）<br>使用<code>*</code>和<code>?</code>来代替多个字符，可以理解为简写的同类约束。<br>形式为 From X to Y？<br>·时序组（Time Group）<br>划分组实现区域的全局约束。</p><h3 id="（5）在quartus中增加时序约束"><a href="#（5）在quartus中增加时序约束" class="headerlink" title="（5）在quartus中增加时序约束"></a>（5）在quartus中增加时序约束</h3><p>具体的方法前面已经介绍了，注意一下实际操作时选择好约束方式。</p><h1 id="三、高级时序分析"><a href="#三、高级时序分析" class="headerlink" title="三、高级时序分析"></a>三、高级时序分析</h1><p>这部分的内容在掌握了基本的时序约束后再回过头来学，现在学会比较吃力。</p><h1 id="四、最小化时序分析"><a href="#四、最小化时序分析" class="headerlink" title="四、最小化时序分析"></a>四、最小化时序分析</h1><p>这也是有了一定的基础后再学会比较好。</p><h1 id="五、使用Tcl工具进行高级时序分析"><a href="#五、使用Tcl工具进行高级时序分析" class="headerlink" title="五、使用Tcl工具进行高级时序分析"></a>五、使用Tcl工具进行高级时序分析</h1><p>这部分的学习也要留到后面，但可以先行阅读。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>这次的学习主要是为实际设计中的后仿真储备知识，认真的了解时序的知识可以为高速电路的设计开个好头。这次只是学习了基本的时序约束的原理和方法。实际的操作还是需要在实践中熟练。具体的问题还是要到实践中找。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;时序约束与时序分析&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、时序约束与时序分析基础&quot;&gt;&lt;a href=&quot;#一、时序约束与时序分析基础&quot; class=&quot;headerlink&quot; title=&quot;一、时序约束与时序分析基础&quot;&gt;&lt;/a&gt;一、时序约束与时序分析基础&lt;/h1&gt;&lt;h2 id=&quot;1-时序约束的说明&quot;&gt;&lt;a href=&quot;#1-时序约束的说明&quot; class=&quot;headerlink&quot; title=&quot;1.时序约束的说明&quot;&gt;&lt;/a&gt;1.时序约束的说明&lt;/h2&gt;&lt;p&gt;设计中常用的约束（Assignment or Constraints）主要有时序约束、区域约束和位置约束。还有一些不常见的约束。&lt;br&gt;时序约束的主要的作用是提高设计的工作频率和获得正确的时序分析报告。&lt;br&gt;时序约束的方式有静态约束（STA）和动态时序约束，区别在于STA只关注时序性能，不考虑其他逻辑因素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="Altera" scheme="https://github.com/electricdream11/tags/Altera/"/>
    
  </entry>
  
  <entry>
    <title>流水灯功能设计</title>
    <link href="https://github.com/electricdream11/2019/10/27/%E6%B5%81%E6%B0%B4%E7%81%AF%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    <id>https://github.com/electricdream11/2019/10/27/流水灯功能设计/</id>
    <published>2019-10-27T14:26:37.000Z</published>
    <updated>2019-10-27T14:30:11.333Z</updated>
    
    <content type="html"><![CDATA[<pre><code>流水灯的设计</code></pre><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>实现基本的组合逻辑还是比较简单的，主要是学习一下计时器的设计。</p><a id="more"></a><h1 id="二、实验原理"><a href="#二、实验原理" class="headerlink" title="二、实验原理"></a>二、实验原理</h1><p>经典的流水灯的设计，具体就不说明了。主要是按键控制，时钟定时，流水灯显示。</p><h1 id="三、实验操作"><a href="#三、实验操作" class="headerlink" title="三、实验操作"></a>三、实验操作</h1><h2 id="1、系统设计"><a href="#1、系统设计" class="headerlink" title="1、系统设计"></a>1、系统设计</h2><p>经典的结构，由于是已经设计好的功能，就不用自己设计了。</p><h2 id="2、电路设计与输入"><a href="#2、电路设计与输入" class="headerlink" title="2、电路设计与输入"></a>2、电路设计与输入</h2><p>（1）verilog代码的编写</p><p>module LED_key(<br>input [3:0] key,<br>input Rst_n,<br>input Clk,</p><p>output reg [3:0] led<br>);</p><p>reg [23:0] cnt;<br>reg [1:0] state_led;<br>//time counter for every 0.2s change </p><p>always@(posedge Clk or negedge Rst_n)begin<br>    if(!Rst_n)<br>    cnt &lt;= 1’b0;<br>    else if(cnt == 24’d1000_0000)<br>    cnt &lt;=1’b0;<br>    else<br>    cnt &lt;= cnt +1’b1;<br>end<br>//state counter<br>always@(posedge Clk or negedge Rst_n)begin<br>    if(!Rst_n)<br>    state_led &lt;= 2’b0;<br>    else if(cnt == 24’d1000_0000)<br>    state_led &lt;= state_led+1’b1;<br>    else if(state_led == 2’b11)  // not need<br>    state_led &lt;=2’b0;<br>end<br>//key in and led out<br>always@(posedge Clk or negedge Rst_n)begin<br>    if(!Rst_n)<br>    led &lt;=4’b0000;<br>    else if(key[0] == 1’b0)<br>    //form1:from right to left<br>            case(state_led)<br>            2’b00: led &lt;=4’b0001;<br>            2’b01: led &lt;=4’b0010;<br>            2’b10: led &lt;=4’b0100;<br>            2’b11: led &lt;=4’b1000;<br>            endcase<br>    //form2:from left to right<br>    else if(key[1] == 1’b0)<br>            case(state_led)<br>            2’b00: led &lt;=4’b1000;<br>            2’b01: led &lt;=4’b0100;<br>            2’b10: led &lt;=4’b0010;<br>            2’b11: led &lt;=4’b0001;<br>            endcase<br>    //form3: not used<br>    else    if(key[2] == 1’b0)<br>            led &lt;= 4’b1111;<br>    //form4:<br>    else    if(key[3] == 1’b0)<br>            led &lt;= 4’b0000;<br>end</p><p>endmodule<br>（2）RTL视图</p><img src="/2019/10/27/流水灯功能设计/imag1.png"><h2 id="3、后续操作"><a href="#3、后续操作" class="headerlink" title="3、后续操作"></a>3、后续操作</h2><p>后面的时序约束，时序仿真，综合等工作暂时不做，只是先考虑功能设计。</p><h1 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h1><p>通过了前仿真，功能基本上满足要求。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>在设计细节上：wire类型作为条件判断时要分位进行，reg类型才能使用数值比较进行条件判断。对应电路上也好理解。wire类型类似于电路的总线，是没有总的值的存储的，reg类型才有存储。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;流水灯的设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h1&gt;&lt;p&gt;实现基本的组合逻辑还是比较简单的，主要是学习一下计时器的设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>quartus常用辅助设计工具</title>
    <link href="https://github.com/electricdream11/2019/10/27/quartus%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7/"/>
    <id>https://github.com/electricdream11/2019/10/27/quartus常用辅助设计工具/</id>
    <published>2019-10-27T11:39:54.000Z</published>
    <updated>2019-10-27T11:44:49.678Z</updated>
    
    <content type="html"><![CDATA[<pre><code>quartus常用的辅助设计工具</code></pre><h1 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h1><p>Quartus中有许多的辅助设计工具可以实现设计流程中许多的功能，可以极大的减轻设计的复杂程度和时间周期。掌握好这些工具，是准备进入更好的层次的设计的关键方法。</p><a id="more"></a><h1 id="二、IO分配验证"><a href="#二、IO分配验证" class="headerlink" title="二、IO分配验证"></a>二、IO分配验证</h1><h2 id="1-IO分配验证"><a href="#1-IO分配验证" class="headerlink" title="1.IO分配验证"></a>1.IO分配验证</h2><p>使用【start IO Assignment Analysis】可以检测IO分配的合法性</p><h2 id="2-IO分配验证流程"><a href="#2-IO分配验证流程" class="headerlink" title="2.IO分配验证流程"></a>2.IO分配验证流程</h2><p>分为有设计文件和无设计文件，主要考虑IO引脚是否符合设计规则。具体的设计规则在使用规范中有。<br>（1）无设计文件的IO分配验证设计流程<br>只是基于qpf文件检测<br>（2）有部分或全部设计文件的IO分配设计流程<br>综合了qdf和其他设计文件的检测</p><h2 id="3-用于IO验证的输入"><a href="#3-用于IO验证的输入" class="headerlink" title="3.用于IO验证的输入"></a>3.用于IO验证的输入</h2><p>所有的输入都是在QSF文件中。</p><h2 id="4-运行IO分配验证"><a href="#4-运行IO分配验证" class="headerlink" title="4.运行IO分配验证"></a>4.运行IO分配验证</h2><p>在启动验证命令后即可得到验证的结果。可以根据结果做出合理的调整。</p><h1 id="三、功率分析"><a href="#三、功率分析" class="headerlink" title="三、功率分析"></a>三、功率分析</h1><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h2><p>大规模的设计中功率是具体性能的重要参数。</p><h2 id="2-Excel-based功率计数器"><a href="#2-Excel-based功率计数器" class="headerlink" title="2.Excel-based功率计数器"></a>2.Excel-based功率计数器</h2><p>用户自己输入参数实现功率的计算，可以在设计完成之前进行。其准确性取决于输入的参数。</p><h2 id="3-Simlation-based功率估算"><a href="#3-Simlation-based功率估算" class="headerlink" title="3.Simlation-based功率估算"></a>3.Simlation-based功率估算</h2><p>用户需要提供vwf矢量波形文件或功率输入文件pwf，并且要执行时序仿真。</p><h1 id="四、RTL阅读器"><a href="#四、RTL阅读器" class="headerlink" title="四、RTL阅读器"></a>四、RTL阅读器</h1><p>这个工具在功能仿真时已经用过许多次了。RTL寄存器传输级的展示工具，可以直观的将自己的设计具体到寄存器级的电路中去。</p><h1 id="五、SignalProbe及SignalTapII逻辑分析器"><a href="#五、SignalProbe及SignalTapII逻辑分析器" class="headerlink" title="五、SignalProbe及SignalTapII逻辑分析器"></a>五、SignalProbe及SignalTapII逻辑分析器</h1><h2 id="1-signalProbe"><a href="#1-signalProbe" class="headerlink" title="1.signalProbe"></a>1.signalProbe</h2><p>（1）添加参数<br>在设置管脚中打开signalprobe的选项后即可将其添加到输入参数。<br>（2）编译及配置<br>编译时可以自动的布线signalprobe信号。（在设置中可以选择）</p><h2 id="2-SignalTapII"><a href="#2-SignalTapII" class="headerlink" title="2.SignalTapII"></a>2.SignalTapII</h2><p>（1）用户界面<br>在tools中可以打开<br>（2）分析仪的使用<br>创建STP文件即可实现所有的设置，具体的操作在实际设计中熟悉。<br>（3）优缺点<br>不占用管脚，不占用PCB，不破坏信号的完整性，价格便宜；<br>使用了剩余的RAM块来实现，会包含在整个的工程中。</p><h1 id="六、时序收敛平面布局规划器（timing-closure-floorplan）"><a href="#六、时序收敛平面布局规划器（timing-closure-floorplan）" class="headerlink" title="六、时序收敛平面布局规划器（timing closure floorplan）"></a>六、时序收敛平面布局规划器（timing closure floorplan）</h1><h2 id="1-用户界面"><a href="#1-用户界面" class="headerlink" title="1.用户界面"></a>1.用户界面</h2><p>在assignment中启动可以查看</p><h2 id="2-查看资源分配"><a href="#2-查看资源分配" class="headerlink" title="2.查看资源分配"></a>2.查看资源分配</h2><p>在view中可以查看实际的视图。</p><h2 id="3-logiclock区域连接"><a href="#3-logiclock区域连接" class="headerlink" title="3.logiclock区域连接"></a>3.logiclock区域连接</h2><p>可以具体的查看两个logiclock间的连接数。</p><h2 id="4-Timing-Closure-Floorplan的关键路径"><a href="#4-Timing-Closure-Floorplan的关键路径" class="headerlink" title="4.Timing Closure Floorplan的关键路径"></a>4.Timing Closure Floorplan的关键路径</h2><p>也是在view中打开选项即可</p><h2 id="5-物理延时估计"><a href="#5-物理延时估计" class="headerlink" title="5.物理延时估计"></a>5.物理延时估计</h2><p>在LAB中view即可找到相应的视图观察与其他模块的延时。</p><h2 id="6-布线阻塞"><a href="#6-布线阻塞" class="headerlink" title="6.布线阻塞"></a>6.布线阻塞</h2><p>设置布线阻塞的标准后在视图中即可查看。</p><h2 id="7-设计优化"><a href="#7-设计优化" class="headerlink" title="7.设计优化"></a>7.设计优化</h2><p>可以较好的控制时序</p><h1 id="七、Chip-Editor底层编辑器"><a href="#七、Chip-Editor底层编辑器" class="headerlink" title="七、Chip Editor底层编辑器"></a>七、Chip Editor底层编辑器</h1><h2 id="1-功能简介"><a href="#1-功能简介" class="headerlink" title="1.功能简介"></a>1.功能简介</h2><p>查看布线资源、LE配置、IO单元配置、PLL配置等门级功能</p><h2 id="2-设计流程"><a href="#2-设计流程" class="headerlink" title="2.设计流程"></a>2.设计流程</h2><p>可以直接对输出的文件进行修改，可以缩短设计的周期。但是只能处理小的错误。</p><h2 id="3-整体视图"><a href="#3-整体视图" class="headerlink" title="3.整体视图"></a>3.整体视图</h2><p>在tools中即可打开查看，为分层视图。</p><h2 id="4-资源特性编辑器"><a href="#4-资源特性编辑器" class="headerlink" title="4.资源特性编辑器"></a>4.资源特性编辑器</h2><p>可以修改最小的逻辑单元LE，是深入到了FPGA内部结构的操作方法。<br>（1）逻辑单元的特性<br>LE有正常和算数两种工作模式，显示为LUT方程。通过修改LUT方程可以实现对整体的逻辑功能的修改。也可以修改LUT真值表来实现。<br>（3）具体的修改规则<br>LUT方程、输入反相、编辑连接、增加或删除寄存器、在LE中使用反馈路径、更改LE的模式。</p><h2 id="5-Chip-Editor的一般应用"><a href="#5-Chip-Editor的一般应用" class="headerlink" title="5.Chip Editor的一般应用"></a>5.Chip Editor的一般应用</h2><p>（1）门级寄存器重定时<br>（2）内部信号到输出管脚的布线<br>（3）调整PLL的相移<br>（4）快速修正设计缺陷</p><h1 id="八、工程更改管理（ECO）"><a href="#八、工程更改管理（ECO）" class="headerlink" title="八、工程更改管理（ECO）"></a>八、工程更改管理（ECO）</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>（1）可以将已经做好的设计优化保存<br>（2）编译时间的缩短，可以在已经编译的文件上编译<br>（3）可以在ECO影响区域做设计，以减少验证时间<br>（4）文档，可以在更改时留下记录以方便其他人员修改应用。</p><h2 id="2-应用范围"><a href="#2-应用范围" class="headerlink" title="2.应用范围"></a>2.应用范围</h2><p>HDL阶段和网表阶段</p><h2 id="3-操作"><a href="#3-操作" class="headerlink" title="3.操作"></a>3.操作</h2><p>在chip editor 中找到修改单元后修改保存后运行ECO布局</p><h2 id="4-使用Change-Manager-查看和管理更改"><a href="#4-使用Change-Manager-查看和管理更改" class="headerlink" title="4.使用Change Manager 查看和管理更改"></a>4.使用Change Manager 查看和管理更改</h2><p>在运行ECO布局操作后会有操作记录，可以用于随时的删除或应用。</p><h2 id="5-ECO验证"><a href="#5-ECO验证" class="headerlink" title="5.ECO验证"></a>5.ECO验证</h2><p>在quartus 4.0后续的版本中不在需要全编译，只要单独运行Assembler或是EDA Netlist Writer即可生成新的配置文件。</p><h1 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h1><p>常用的辅助设计工具熟悉一遍，具体的使用还是要在具体的是实践中去做。工欲善其事必先利其器，尽可能熟悉这些工具可以减轻实际的操作的压力。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;quartus常用的辅助设计工具&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h1&gt;&lt;p&gt;Quartus中有许多的辅助设计工具可以实现设计流程中许多的功能，可以极大的减轻设计的复杂程度和时间周期。掌握好这些工具，是准备进入更好的层次的设计的关键方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="Altera" scheme="https://github.com/electricdream11/tags/Altera/"/>
    
  </entry>
  
  <entry>
    <title>阶乘器</title>
    <link href="https://github.com/electricdream11/2019/10/25/%E9%98%B6%E4%B9%98%E5%99%A8/"/>
    <id>https://github.com/electricdream11/2019/10/25/阶乘器/</id>
    <published>2019-10-25T14:06:08.000Z</published>
    <updated>2019-10-25T14:11:28.514Z</updated>
    
    <content type="html"><![CDATA[<pre><code>基于CPLD的运算器设计</code></pre><h1 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h1><p>以相对简单的CPLD芯片为模板，深入的了解可编程逻辑器件的设计原则、设计思想、代码风格、时钟管理、IO接口设计等基本的知识，掌握根据官网的英文资料提炼所需的信息的能力，熟悉设计的流程。</p><a id="more"></a><h1 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h1><h2 id="1-初步的构想"><a href="#1-初步的构想" class="headerlink" title="1.初步的构想"></a>1.初步的构想</h2><p>使用组合逻辑电路制作一个阶乘器来表现速度的参数性能，根据资源的消耗量来衡量面积，最后做出优化。由于CPLD的时钟资源不多，就尽量空出多的时序余量。所以，不会考虑用速度换面积，只需要做到用面积换速度。</p><h2 id="2-系统功能定义和逻辑功能划分"><a href="#2-系统功能定义和逻辑功能划分" class="headerlink" title="2.系统功能定义和逻辑功能划分"></a>2.系统功能定义和逻辑功能划分</h2><p>系统功能：阶乘器要实现对10（初步考虑为这么大，逻辑硬件运算的资源消耗较大）以内的非零自然数实现阶乘。数学表达式是<code>a！=a*(a-1)*……*1。</code><br>逻辑功能：这次就是考虑速度与面积的转化，不会涉及其他的逻辑控制，这部分就先省略。</p><h2 id="3-设计的初步预算"><a href="#3-设计的初步预算" class="headerlink" title="3.设计的初步预算"></a>3.设计的初步预算</h2><p>时钟频率：暂时采用系统默认的时钟，采用低速设计，在优化时提速。<br>时钟结构：采用全局时钟。<br>可能的关键路径：乘法器可能比较拥挤。</p><h2 id="4-芯片选型："><a href="#4-芯片选型：" class="headerlink" title="4.芯片选型："></a>4.芯片选型：</h2><p>family ：MAX II<br>Name：EPM240F100C4<br>Core Voltage：3.3V<br>LEs：240<br>UFM blocks：1</p><h2 id="5-逻辑模块的划分及接口的定义"><a href="#5-逻辑模块的划分及接口的定义" class="headerlink" title="5.逻辑模块的划分及接口的定义"></a>5.逻辑模块的划分及接口的定义</h2><p>（1）如果使用纯组合电路实现的话需要10-1个乘法器级联，只需要一个模块即可。<br>（2）如果只使用一个乘法器完成操作，则需要使用10-1次的循环结构来实现，也只需要一个模型。<br>考虑到硬件的资源有限，使用第二种方法更容易实现。<br>顶层模块topmodule：4位输入和23位输出；<br>子模块mod1：实现阶乘操作                                                                          </p><h2 id="6-子模块的设计流程"><a href="#6-子模块的设计流程" class="headerlink" title="6.子模块的设计流程"></a>6.子模块的设计流程</h2><p>简单的循环体：<br>（1）循环初始化：可以选择从1乘到A或从A乘到1，从条件判断的简易程度看，选择从1乘到A会更好，即初始值为1；<br>（3）循环操作：调用乘法器将待输出值B_out与A_temp相乘。<br>（4）循环终止条件：A_temp&gt;=A<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module mod1(</span><br><span class="line">input [3:0] A_in,</span><br><span class="line">input Clk,</span><br><span class="line">input Rst_n,</span><br><span class="line"></span><br><span class="line">output reg [23:0] A_out</span><br><span class="line">);</span><br><span class="line">reg [3:0] A_copy;</span><br><span class="line">reg [3:0] A_temp;</span><br><span class="line">always@(*)</span><br><span class="line">A_copy &lt;=A_in;</span><br><span class="line">always@(posedge Clk or negedge Rst_n )begin</span><br><span class="line">if(!Rst_n)begin</span><br><span class="line">A_temp &lt;=1&apos;b1;</span><br><span class="line">A_out &lt;= 1&apos;b1;</span><br><span class="line">end</span><br><span class="line">else if(A_temp &gt; A_copy)</span><br><span class="line">A_out &lt;= A_out;</span><br><span class="line">else  begin</span><br><span class="line">A_out &lt;= A_out * A_temp;</span><br><span class="line">A_temp &lt;= A_temp +1&apos;b1;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="7-模块合并测试"><a href="#7-模块合并测试" class="headerlink" title="7.模块合并测试"></a>7.模块合并测试</h2><p>合并：只有一个模块，直接连接接口即可，注意wire型变量连接为驱动。<br>测试：<br>查看生成的RTL视图</p><img src="/2019/10/25/阶乘器/imag1.png"><p>资源报告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flow StatusSuccessful - Fri Oct 25 20:20:15 2019</span><br><span class="line">Quartus II 64-Bit Version11.0 Build 208 07/03/2011 SP 1 SJ Full Version</span><br><span class="line">Revision NamemaxII</span><br><span class="line">Top-level Entity NamemaxII</span><br><span class="line">FamilyMAX II</span><br><span class="line">DeviceEPM240F100C4</span><br><span class="line">Timing ModelsFinal</span><br><span class="line">Total logic elements127</span><br><span class="line">Total pins30</span><br><span class="line">Total virtual pins0</span><br><span class="line">UFM blocks0 / 1 ( 0 % )</span><br></pre></td></tr></table></figure><h2 id="8-仿真"><a href="#8-仿真" class="headerlink" title="8.仿真"></a>8.仿真</h2><p>测试脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">`define clk_p 5</span><br><span class="line">module maxII_tb;</span><br><span class="line">reg [3:0] A_in;</span><br><span class="line">reg Clk;</span><br><span class="line">reg Rst_n;</span><br><span class="line">wire [23:0] A_out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxII Ut1(</span><br><span class="line">.A_in(A_in),</span><br><span class="line">.Clk(Clk),</span><br><span class="line">.Rst_n(Rst_n),</span><br><span class="line"></span><br><span class="line">.A_out(A_out)</span><br><span class="line">);</span><br><span class="line">initial begin</span><br><span class="line">Clk   =1&apos;b0;</span><br><span class="line">Rst_n =1&apos;b0;</span><br><span class="line">A_in  =4&apos;b1111;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always#(`clk_p/2) Clk = ~Clk;</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">#(`clk_p*10)</span><br><span class="line">Rst_n = 1&apos;b1;</span><br><span class="line">#(`clk_p*30)</span><br><span class="line">$stop;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="/2019/10/25/阶乘器/imag2.png"><h1 id="三、后仿真实现"><a href="#三、后仿真实现" class="headerlink" title="三、后仿真实现"></a>三、后仿真实现</h1><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h2><p>后仿真是将设计的硬件电路加入到实际的器件中的测试，需要更多考虑。做好后仿真时实现实际的生产的关键一步。</p><h2 id="2-后仿真约束"><a href="#2-后仿真约束" class="headerlink" title="2.后仿真约束"></a>2.后仿真约束</h2><p>这部分暂时还没有掌握，具体的尝试就不展示了。暂时就先做功能仿真。</p><h2 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h2><p>略</p><h1 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h1><p>由前面的设计思路可以知道，使用一个乘法器是面积最小的方案，所耗费的时间也是最长的。<br>初步的优化方案是将从一端开始乘变成从两端开始乘以提高速度。具体的设计可能没有时间做了，现在先感受一下。</p><h1 id="五、结果"><a href="#五、结果" class="headerlink" title="五、结果"></a>五、结果</h1><p>略</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>这次的学习经历了两天，大概的巩固了一下FPGA设计三部分的第一部分的大体内容，了解了一下第二阶段的流程。接下来准备好第二阶段的基础知识，为下一段的学习准备好。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;基于CPLD的运算器设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;一、目标&quot;&gt;&lt;a href=&quot;#一、目标&quot; class=&quot;headerlink&quot; title=&quot;一、目标&quot;&gt;&lt;/a&gt;一、目标&lt;/h1&gt;&lt;p&gt;以相对简单的CPLD芯片为模板，深入的了解可编程逻辑器件的设计原则、设计思想、代码风格、时钟管理、IO接口设计等基本的知识，掌握根据官网的英文资料提炼所需的信息的能力，熟悉设计的流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>Altera器件的高级特性</title>
    <link href="https://github.com/electricdream11/2019/10/23/Altera%E5%99%A8%E4%BB%B6%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://github.com/electricdream11/2019/10/23/Altera器件的高级特性/</id>
    <published>2019-10-23T13:28:55.000Z</published>
    <updated>2019-10-23T13:35:20.901Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Altera器件的高级特性与应用</code></pre><p>   高性能、大容量的FPGA正在逐渐成为系统中的核心组成部分，这意味着FPGA逐渐的引入一些专用的电路以提高性能。这也要求设计者掌握这些专用的电路的设计方法。<br>   <a id="more"></a></p><h1 id="一、时钟管理"><a href="#一、时钟管理" class="headerlink" title="一、时钟管理"></a>一、时钟管理</h1><p>时钟作为时序的执行者，是一切时序的基石。</p><h2 id="1-时钟问题"><a href="#1-时钟问题" class="headerlink" title="1.时钟问题"></a>1.时钟问题</h2><h3 id="（1）时钟偏斜（Skew）和抖动（Jitter）"><a href="#（1）时钟偏斜（Skew）和抖动（Jitter）" class="headerlink" title="（1）时钟偏斜（Skew）和抖动（Jitter）"></a>（1）时钟偏斜（Skew）和抖动（Jitter）</h3><p>时钟偏斜是指时钟分配系统中到达各个时钟末端的（器件触发器的时钟输入端）时钟相位不一样的现象。主要由时钟源不同步和分配网络不同步引起的。设计时要考虑偏斜的时序影响。<br>时钟抖动是时钟信号实际的触发时间与理想的时间有偏差造成的现象。一般有可确定的和不可确定的两种情形。在抖动达到一定的程度时需要削弱。</p><h3 id="（2）时序余量"><a href="#（2）时序余量" class="headerlink" title="（2）时序余量"></a>（2）时序余量</h3><p>所有的时序延迟必须约束在一个时钟周期内。<br>源触发器的输出延时（MicroTco）、触发器到触发器的走线及逻辑延时（Tlogic）、目的触发器的建立时间（MicroTsu）和保持时间（MicroTh）<br>时钟建立的原则就是MicroTco+Tlogic+MicroTsu小于时钟周期T。<br>在计算同步IO引脚的时序余量时，发送器件的时钟输出延时Tco、单板走线延时Tfight以及接收器的建立时间Tsu和保持时间Th。时钟的设计原则就是Tco+Tfight+Tsu小于时钟周期T。<br>实际的设计过程中，尤其是在高速板中，时钟源的偏斜和抖动也是要考虑在时序余量中的。现在的设计有源同步（数据和相位一起发送）方案和动态相位调整（DPA）电路可以解决问题。<br>CDR（时钟动态恢复）电路逐渐成为高速电路中的高速高带宽系统的互联方案。</p><h3 id="（3）使用全局时钟网络和锁相环改善时钟"><a href="#（3）使用全局时钟网络和锁相环改善时钟" class="headerlink" title="（3）使用全局时钟网络和锁相环改善时钟"></a>（3）使用全局时钟网络和锁相环改善时钟</h3><p>全局时钟网络由芯片中心向四周拓展，保证偏斜很小。此外，采用时钟保护以排除其他信号的影响。<br>！有一些时钟资源为局部时钟信号，不能走芯片的所有地方。<br>在EDA工具中可以设置是否使用全局时钟，也可以设置引脚的时钟类型。<br>PLL（锁相环）可以滤除抖动，提高时钟质量和效率，是比较好的时钟信号选择。</p><h3 id="（4）局部走线"><a href="#（4）局部走线" class="headerlink" title="（4）局部走线"></a>（4）局部走线</h3><p>使用局部走线来实现时钟会有较大的偏斜，一般用于时序约束不是非常严格的电路中。在全局时钟不足时使用。<br>！LCELL（传输门）语句可以实现延时，综合时要将Ignore LCEL Buffers选项关闭以防被忽略。</p><h2 id="2-锁相环的应用"><a href="#2-锁相环的应用" class="headerlink" title="2.锁相环的应用"></a>2.锁相环的应用</h2><h3 id="（1）PLL（锁相环）和DLL（延时锁定环）"><a href="#（1）PLL（锁相环）和DLL（延时锁定环）" class="headerlink" title="（1）PLL（锁相环）和DLL（延时锁定环）"></a>（1）PLL（锁相环）和DLL（延时锁定环）</h3><p>锁相环（PLL）由模拟电路构成，输出时钟由内部自振产生，输入时钟频率受限，所带来的抖动为自身结构产生，对噪声敏感。<br>延时锁定环（DLL）由数字电路实现，时钟输出真实，能及时反映输入时钟。输入频率较宽，但有频率下限。会引入输入时钟的固定抖动，造成时钟抖动积累。对噪声不敏感。</p><h3 id="（2）altera中的PLL"><a href="#（2）altera中的PLL" class="headerlink" title="（2）altera中的PLL"></a>（2）altera中的PLL</h3><p>Stratix主要有EPLL（增强型锁相环）和FPLL（快速锁相环）<br>Cyclone有快速锁相环。<br>具体的问题需要在设计中自行体会，相关的说明在用时查找器件说明。</p><h3 id="（3）PLL电源设计"><a href="#（3）PLL电源设计" class="headerlink" title="（3）PLL电源设计"></a>（3）PLL电源设计</h3><p>数字电源中有较多的噪声，PLL为模拟电路，需要单独的电源。</p><h3 id="（4）工具支持"><a href="#（4）工具支持" class="headerlink" title="（4）工具支持"></a>（4）工具支持</h3><p>使用MegaWiard实现需要的锁相环（PLL）</p><h1 id="二、Arria10器件的高级特性与应用"><a href="#二、Arria10器件的高级特性与应用" class="headerlink" title="二、Arria10器件的高级特性与应用"></a>二、Arria10器件的高级特性与应用</h1><h2 id="1-硬浮点DSP块介绍"><a href="#1-硬浮点DSP块介绍" class="headerlink" title="1.硬浮点DSP块介绍"></a>1.硬浮点DSP块介绍</h2><p>DSP在运算上具有较大的优势，合理的使用DSP可以提高速度。Arria 10中的硬浮点性能可以支持雷达和医疗图像等方面的应用。</p><h2 id="2-Altera-FPGA中浮点DSP实现的演进"><a href="#2-Altera-FPGA中浮点DSP实现的演进" class="headerlink" title="2.Altera FPGA中浮点DSP实现的演进"></a>2.Altera FPGA中浮点DSP实现的演进</h2><p>采用硬浮点可以有效地减少LUT和寄存器的消耗。</p><h2 id="3-硬浮点DSP的优势"><a href="#3-硬浮点DSP的优势" class="headerlink" title="3.硬浮点DSP的优势"></a>3.硬浮点DSP的优势</h2><p>使用浮点计算可以减少定点运算的庞大的资源消耗。<br>可以使用DSP Builder来实现DSP的利用。</p><h2 id="4-Xilinx-Ultrascale-DSP48E2"><a href="#4-Xilinx-Ultrascale-DSP48E2" class="headerlink" title="4.Xilinx Ultrascale DSP48E2"></a>4.Xilinx Ultrascale DSP48E2</h2><p>具体的芯片上的设计资源都要在实际的实际中查找应用。</p><h1 id="三、片外高速存储器"><a href="#三、片外高速存储器" class="headerlink" title="三、片外高速存储器"></a>三、片外高速存储器</h1><p>与片外的高速存储器的连用是提高设计功能的有效方法。</p><h2 id="1-外部存储接口方案的关键特性"><a href="#1-外部存储接口方案的关键特性" class="headerlink" title="1.外部存储接口方案的关键特性"></a>1.外部存储接口方案的关键特性</h2><p>Arria 10 新的存储接口方案在控制器和控制器到PHY方面做了预先的时序收敛。<br>（1）外部存储接口硬核化<br>（2）IO列与内部逻辑混合<br>（3）单个Nios II 硬核标准IO列里面的所有存储接口<br>（4）IO列由IObank组成。每个IObank包含一个专有的整数PLL（IO_PLL）,一个硬的存储器和一个DLL<br>（5）PHY时钟树比上一代器件变短了并且只跨一个IObank<br>（6）如果需要跨多个IObank，那么就要求用多个PLL</p><h2 id="2-支持的存储标准"><a href="#2-支持的存储标准" class="headerlink" title="2.支持的存储标准"></a>2.支持的存储标准</h2><p>不同的FPGA硬核、软核和HPS都有相应支持标准，需要使用时查找就好。</p><h2 id="3-存储接口宽度"><a href="#3-存储接口宽度" class="headerlink" title="3.存储接口宽度"></a>3.存储接口宽度</h2><p>不一样的接口宽度对应不同的IO bank数来配合。</p><h2 id="4-IO管脚"><a href="#4-IO管脚" class="headerlink" title="4.IO管脚"></a>4.IO管脚</h2><p>每一个IO bank都带有外部存储接口电路，并且IO bank 里面的控制器只能驱动同一个 IO bank 里面的地址/命令线，同时可以驱动IObank的数据线。没有使用的IO口可以当普通IO口使用。</p><h2 id="5-外部存储接口IP支持类型"><a href="#5-外部存储接口IP支持类型" class="headerlink" title="5.外部存储接口IP支持类型"></a>5.外部存储接口IP支持类型</h2><p>A10的IP支持的类型也是需要确定存储颗粒标准。</p><h2 id="6-Arria10外部存储接口类型"><a href="#6-Arria10外部存储接口类型" class="headerlink" title="6.Arria10外部存储接口类型"></a>6.Arria10外部存储接口类型</h2><p>A10的外部存储接口框架有比较独特的结构，具体的就不写了，在芯片应用时细看。现在还在初学阶段，具体的功能在实践中实例。</p><h1 id="四、Hybird-Memory-Cube"><a href="#四、Hybird-Memory-Cube" class="headerlink" title="四、Hybird Memory Cube"></a>四、Hybird Memory Cube</h1><p>高速的处理能力要求高速的存储器件。</p><h2 id="1-存储带宽面临的挑战"><a href="#1-存储带宽面临的挑战" class="headerlink" title="1.存储带宽面临的挑战"></a>1.存储带宽面临的挑战</h2><p>存储墙的限制使电子系统遇到了瓶颈。</p><h2 id="2-HMC的优势"><a href="#2-HMC的优势" class="headerlink" title="2.HMC的优势"></a>2.HMC的优势</h2><p>HMC的先进的工艺为高速性能提供了支持，具体的设计参数需要设计时去查。</p><h2 id="3-Altera-HMC-交互操作平台"><a href="#3-Altera-HMC-交互操作平台" class="headerlink" title="3.Altera HMC 交互操作平台"></a>3.Altera HMC 交互操作平台</h2><p>Altera和HMC打造的操作平台，可以提供硬件的支持。</p><h2 id="4-Altera-HMC路标"><a href="#4-Altera-HMC路标" class="headerlink" title="4.Altera HMC路标"></a>4.Altera HMC路标</h2><p>A10 后可以支持HMC接口。</p><h2 id="5-网络系统的应用实例"><a href="#5-网络系统的应用实例" class="headerlink" title="5.网络系统的应用实例"></a>5.网络系统的应用实例</h2><p>HMC可以有效地提高速度。具体的分析就做了。</p><h1 id="五、Altera-JESD204B-Megacore"><a href="#五、Altera-JESD204B-Megacore" class="headerlink" title="五、Altera JESD204B Megacore"></a>五、Altera JESD204B Megacore</h1><p>具体的高速串行接口</p><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>该IP包含MAC（介质层）和PHY（物理层），可以提供高速传输的保障。具体的选择在IP手册中查找。配置也在其中选择。</p><h2 id="2-功能描述"><a href="#2-功能描述" class="headerlink" title="2.功能描述"></a>2.功能描述</h2><p>MAC中主要为DLL模块，PHY中主要有PCS和PMA模块。具体的性能还是在具体使用时体会。</p><h2 id="3-Debug指导"><a href="#3-Debug指导" class="headerlink" title="3.Debug指导"></a>3.Debug指导</h2><p>在设计过程中调试时再具体的处理，主要是要考虑高速电路的各种问题。</p><h1 id="六、高速串行收发器"><a href="#六、高速串行收发器" class="headerlink" title="六、高速串行收发器"></a>六、高速串行收发器</h1><p>这部分主要包含了高速串发器的主要的参数和设计注意事项。在实践中具体的学习，单纯的阅读时没有太大的意义。结合实际的操作才是了解这类结构的根本的手段。以下是设计的具体的流程，具体的在实际操作中查找训练。<br>1.Arria 10 Transceiver概述<br>2.Transceiver设计流程<br>3.PLL和时钟网络<br>4.复位Transceiver通道<br>5.重配接口和动态重配<br>6.校准</p><h1 id="七、小结"><a href="#七、小结" class="headerlink" title="七、小结"></a>七、小结</h1><p>高速是电路性能标准之一，设计高速电路的能力是一个设计者的基本能力，这也是电子工程师进阶的必经之路。学好如何设计高速电路需要大量的实践，认真的学习后对接下来的提升具有重要的意义。这次的学习主要是为接下来学习高速电路打下基础。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Altera器件的高级特性与应用&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   高性能、大容量的FPGA正在逐渐成为系统中的核心组成部分，这意味着FPGA逐渐的引入一些专用的电路以提高性能。这也要求设计者掌握这些专用的电路的设计方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="Altera" scheme="https://github.com/electricdream11/tags/Altera/"/>
    
  </entry>
  
  <entry>
    <title>可编程逻辑设计指导原则</title>
    <link href="https://github.com/electricdream11/2019/10/22/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99/"/>
    <id>https://github.com/electricdream11/2019/10/22/可编程逻辑设计指导原则/</id>
    <published>2019-10-22T15:20:07.000Z</published>
    <updated>2019-10-22T15:30:00.508Z</updated>
    
    <content type="html"><![CDATA[<pre><code>可编程逻辑设计指导原则</code></pre><p>学习指导原则可以在设计过程中少走很多弯路。</p><a id="more"></a><h1 id="1-基本设计原则"><a href="#1-基本设计原则" class="headerlink" title="1.基本设计原则"></a>1.基本设计原则</h1><h2 id="一、面积和速度（设计质量评价的最终标准）的平衡与互换原则"><a href="#一、面积和速度（设计质量评价的最终标准）的平衡与互换原则" class="headerlink" title="一、面积和速度（设计质量评价的最终标准）的平衡与互换原则"></a>一、面积和速度（设计质量评价的最终标准）的平衡与互换原则</h2><p>   “面积”（area）:逻辑资源的数量（对FPGA为FF【触发器】和LUT【查找表】）<br>   “速度”（speed) :芯片稳定运行时的最高频率｛与时钟周期等众多的时序特征量密切相关｝<br>    ！一般优先考虑速度<br>   面积与速度的转化：加大并行量可以提高工作的频率，拉长流水线可以减小面积；</p><h2 id="二、硬件原则"><a href="#二、硬件原则" class="headerlink" title="二、硬件原则"></a>二、硬件原则</h2><p>   使用硬件描述语言时要时刻注意电路的对应。不同于c语言的关注于语言逻辑，HDL的描述追求的是准确的表达设计，而不是直接的设计。在书写代码时要时刻考虑到建模的对应性。<br>   verilog对系统行为的描述分为“sysytem”（系统级）、“Algorithm”（算法级）、“RTL”（寄存器传输级）、“logic”（逻辑级）和“gate”（门级）。RTL级后的级别都需要考虑电路的特性。<br>  如ifcase结构在verilog中带有优先级的描述，而case则没有优先级。C中则单纯的是选择语句。<br>  总之，考虑verilog的模型对应是十分重要的设计原则。</p><h2 id="三、系统原则"><a href="#三、系统原则" class="headerlink" title="三、系统原则"></a>三、系统原则</h2><p>   在有了一个需要实现的硬件系统时，系统层次的原则就是设计的起点。<br>   一般来说，实时性要求高、频率快的功能模块需要使用FPGA/CPLD实现。FPGA的触发器资源丰富，CPLD组合逻辑资源丰富。<br>  系统资源的考虑因素：<br>（1）存储器资源的使用<br>     RAM和ROM所用的数量确定了所选的器件。<br>（2）硬核的使用<br>     使用处理核可以提高设计的性能，但要考虑内嵌的处理模块与真正的处理模块的功能的区别。<br>（3）串行收发器的使用<br>     SERDES（串行收发器），完成高速的串行信号收发。可以有效地解决高速系统中数据传输的瓶颈。<br>（4）其他结构的使用<br>     选择IO：功耗，传输距离，抗干扰性和EMI<br>     选择布线资源和时钟资源：速度等级（设计速度由电路的整体结构和代码风格决定）<br>（5）拓展<br>     模块化设计是大型复杂系统的推荐的设计方法。</p><h2 id="四、同步设计原则"><a href="#四、同步设计原则" class="headerlink" title="四、同步设计原则"></a>四、同步设计原则</h2><p>  同步的时序的设计可以有效地解决大规模设计过程中的统一性的问题。可以有效地减少设计的工作量。<br>  同步设计中数据采样必须遵从的原则<br>（1）在有效时钟沿到达前，数据的输入至少已经稳定了采样寄存器的Setup时间（setup原则）<br>（2）在有效时钟沿到达后，数据输入至少还将稳定保持采样寄存器的Hold时间之久（hold原则）</p><h1 id="2-常用设计思想与技巧"><a href="#2-常用设计思想与技巧" class="headerlink" title="2.常用设计思想与技巧"></a>2.常用设计思想与技巧</h1><h2 id="一、乒乓操作"><a href="#一、乒乓操作" class="headerlink" title="一、乒乓操作"></a>一、乒乓操作</h2><p>  采用输入数据选择和输出数据选择两个模块来实现数据的流水线式的算法，可以完成数据的无缝缓冲和处理。可以实现低频模块来处理高频数据。（典型的面积换速度）</p><h2 id="二、串并转换"><a href="#二、串并转换" class="headerlink" title="二、串并转换"></a>二、串并转换</h2><p>   串行结构占速度，并行结构占面积。两者的合理的利用可以达到设计的目标。</p><h2 id="三、流水线操作"><a href="#三、流水线操作" class="headerlink" title="三、流水线操作"></a>三、流水线操作</h2><p>   处理流程和顺序操作的设计思想，是常用的设计手段。如果某个设计的处理流程可以分为若干的步骤，且整个的数据处理是单流向的，没有反馈和迭代，则可以考虑流水线操作。<br>四、异步时钟域的数据处理<br>      处理好异步时钟是提高设计的稳定性的重要的手段。<br>（1）两类异步时钟域同步的表现形式<br>     有同频异相问题和异频问题两种形式。<br>（2）两种不推荐的异步时钟域的操作方法<br>     buffer组合逻辑延时线调整采样（组合逻辑产生的延迟不稳定，会使可维护性和继承性变差）<br>     盲目使用时钟正负边沿调整（双边沿的时钟约束并不可靠，这是专用的高速电路中的做法，而FPGA并不具备这样的条件）<br>（3）异步时钟域数据同步的常用方法<br>       i：同频异相：<br>       用后级时钟对前级数据采样两次，有效地减少亚稳态，可以解决对错误不敏感的单元。<br>       可靠的方法是使用DPRAM，FIFO或寄存器buffer完成异步数据的转换。<br>       ii：异频问题：使用DPRAM或FIFO将数据缓存转化。<br>    （4）亚稳态<br>       异步信号转化时不稳定的信号传输产生的干扰。       </p><h1 id="3-Altera推荐的coding-style"><a href="#3-Altera推荐的coding-style" class="headerlink" title="3.Altera推荐的coding style"></a>3.Altera推荐的coding style</h1><p>   在设计规模的不断地提高的背景下，代码的可移植性变得越来越重要。良好的代码规范可以达到一劳永逸的奇效。<br>   此外，EDA工具虽然可以辅助设计者的代码的实现和优化，但设计者本身的良好代码风格可以事半功倍的达到效果。</p><h2 id="（1）代码风格的含义"><a href="#（1）代码风格的含义" class="headerlink" title="（1）代码风格的含义"></a>（1）代码风格的含义</h2><p>   一般性Coding style 和针对综合工具、实现工具、器件类型的coding style。</p><h2 id="（2）结构层次化编码"><a href="#（2）结构层次化编码" class="headerlink" title="（2）结构层次化编码"></a>（2）结构层次化编码</h2><p>   模块化编码是模块化设计思想的一种体现。一般设计为三到五层就行，不能太深。顶层模块最好只是调用其他的模块，不用于实现复杂的逻辑功能。所有的IO信号都在顶层模块中完成。子模块不宜直接连接，以提高可读性。</p><h2 id="（3）模块划分的技巧"><a href="#（3）模块划分的技巧" class="headerlink" title="（3）模块划分的技巧"></a>（3）模块划分的技巧</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*同步时序设计的子模块的输出使用寄存器（方便时序约束）</span><br><span class="line">【寄存器分割同步时序模块】</span><br><span class="line">*相关逻辑和可复用逻辑划分到同一个模块（方便EDA优化）</span><br><span class="line">【呼应系统原则】</span><br><span class="line">*不同优化目标分开，可以将综合器设置为层次化的优化，提高优化策略。</span><br><span class="line">*松约束逻辑归到一块，指定约束以提高效率</span><br><span class="line">*存储逻辑独立划分模块，可以提高综合和仿真的效率</span><br><span class="line">*模块规模的控制，模块越大越有利于资源共享，但要考虑综合器和仿真器的压力。</span><br></pre></td></tr></table></figure><h2 id="（4）组合逻辑的注意事项"><a href="#（4）组合逻辑的注意事项" class="headerlink" title="（4）组合逻辑的注意事项"></a>（4）组合逻辑的注意事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*避免组合逻辑反馈环路（Combinational Loops）</span><br><span class="line">*替换延迟链（Delay Chains），可以考虑倍频电路使用</span><br><span class="line">*替换异步脉冲产生单元（pulse Generator），产生的信号不稳定</span><br><span class="line">*避免锁存器（Latch），产生的毛刺会影响稳定性。方法主要是考虑完备性</span><br></pre></td></tr></table></figure><h2 id="（5）时钟设计的注意事项"><a href="#（5）时钟设计的注意事项" class="headerlink" title="（5）时钟设计的注意事项"></a>（5）时钟设计的注意事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*时钟设计方法主要是使用主频和变频信号来控制，其他的变通的方法是在现有的资源不足时使用的。</span><br><span class="line">*PLL资源可以有效地对时钟的频率调整。</span><br><span class="line">*时钟布线资源，可以补充主频不足的缺陷</span><br><span class="line">*Ripple Counter（行波计数器）异步时序逻辑，能不用就不用</span><br><span class="line">*时钟选择，需要其他的时钟时最好使用Clock MUX来切换，没有的话也要保证切换不会影响功能（切换会有短暂的错误）</span><br><span class="line">*门控时钟（gate clock），可以减小功耗，但易产生毛刺，不推荐使用。</span><br><span class="line">*时钟同步使能端（Synchronous Clock Enable）可以直接有逻辑电路控制，可以简单的完成一些复杂功能。</span><br></pre></td></tr></table></figure><h2 id="（6）全局异步复位资源"><a href="#（6）全局异步复位资源" class="headerlink" title="（6）全局异步复位资源"></a>（6）全局异步复位资源</h2><p>   可以全局配置复位资源，可以简化设计。</p><h2 id="（7）判断case和if-case的优先级"><a href="#（7）判断case和if-case的优先级" class="headerlink" title="（7）判断case和if case的优先级"></a>（7）判断case和if case的优先级</h2><p>   case是平行，if是优先级。但if也能写出平行的结构。随着综合工具的发展，其已经可以自动去除不必要的优先级树去掉。</p><h2 id="（8）使用Pipelining技术优化时序"><a href="#（8）使用Pipelining技术优化时序" class="headerlink" title="（8）使用Pipelining技术优化时序"></a>（8）使用Pipelining技术优化时序</h2><p>   本质上是长组合逻辑的寄存器的调整以达到提高效率的目的，但不能增加级数。</p><h2 id="（9）模块复用和Resource-Sharing"><a href="#（9）模块复用和Resource-Sharing" class="headerlink" title="（9）模块复用和Resource Sharing"></a>（9）模块复用和Resource Sharing</h2><p> 对复杂模块的复用可以大幅的减少资源的使用量</p><h2 id="（10）逻辑复制"><a href="#（10）逻辑复制" class="headerlink" title="（10）逻辑复制"></a>（10）逻辑复制</h2><p>   对速度占用过多时可以复制信号以提高速度，牺牲面积。</p><h2 id="（11）香农拓展运算"><a href="#（11）香农拓展运算" class="headerlink" title="（11）香农拓展运算"></a>（11）香农拓展运算</h2><p>   卡诺化简的反向运算，相当于逻辑复制，目的也是提高速度。</p><h2 id="（12）信号敏感表"><a href="#（12）信号敏感表" class="headerlink" title="（12）信号敏感表"></a>（12）信号敏感表</h2><p>   将敏感信号全部列出以检查是否有逻辑疏忽。</p><h2 id="（13）状态机设计的一般原则"><a href="#（13）状态机设计的一般原则" class="headerlink" title="（13）状态机设计的一般原则"></a>（13）状态机设计的一般原则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*选择编码方式：gray-code使用较少的触发器，one-hot反之。所以CPLD多用gray-code，而one-hot多用于FPGA。</span><br><span class="line">*设计方法：状态转移和状态的操作、判断、等写到一个模块；状态转移单独成块。两种方法中一般选择后者。</span><br><span class="line">*初始化状态和默认状态，保持状态机的健壮性</span><br><span class="line">*默认输出，也是保持稳定性。</span><br><span class="line">*输出逻辑复用，可减少资源的用量，且不易冲突。</span><br></pre></td></tr></table></figure><h2 id="（14）Altera-Megafunction资源的使用"><a href="#（14）Altera-Megafunction资源的使用" class="headerlink" title="（14）Altera Megafunction资源的使用"></a>（14）Altera Megafunction资源的使用</h2><p>   IP核是稳定的模块，可以提高设计效率和稳定性，就是会增加成本。</p><h2 id="（15）三态信号的设计"><a href="#（15）三态信号的设计" class="headerlink" title="（15）三态信号的设计"></a>（15）三态信号的设计</h2><p>   在顶层中将双向端口定义位三态，且禁止其他的模块有此类定义（除非顶层中直接驱动双向端口），禁止赋值高阻Z。</p><h2 id="（16）加法树的设计"><a href="#（16）加法树的设计" class="headerlink" title="（16）加法树的设计"></a>（16）加法树的设计</h2><p>   基于ALM的可变输入的LUT（查找表），可以设计出合理的加法书以提高查找的效率。查找的数量越少，资源利用率越高。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;可编程逻辑设计指导原则&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;学习指导原则可以在设计过程中少走很多弯路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="Altera" scheme="https://github.com/electricdream11/tags/Altera/"/>
    
  </entry>
  
  <entry>
    <title>IP核的调用</title>
    <link href="https://github.com/electricdream11/2019/10/21/IP%E6%A0%B8%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>https://github.com/electricdream11/2019/10/21/IP核的调用/</id>
    <published>2019-10-21T14:16:14.000Z</published>
    <updated>2019-10-21T14:28:53.342Z</updated>
    
    <content type="html"><![CDATA[<pre><code>IP核的调用</code></pre><h1 id="1-IP核的定义"><a href="#1-IP核的定义" class="headerlink" title="1.IP核的定义"></a>1.IP核的定义</h1><p>  一些写好的IP核就是构建好的可调整的模块化的代码。利用IP核可以快速的完成一些成熟的功能。这好像在考试是使用简化的公式一样。虽然这是一个比较速成的方法，但是要适当的使用，毕竟在初学时掌握完备的体系是后续的基础。</p><a id="more"></a><h1 id="2-IP核的使用"><a href="#2-IP核的使用" class="headerlink" title="2.IP核的使用"></a>2.IP核的使用</h1><p>  在软件上的使用还是相当的简单的，调用相应的工具即可。事实上，仔细的了解IP的写法也是不错的学习方法，尤其是学习IP的结构。IP核是经过仔细的测试的，在设计上也是相当成熟的。但这是在掌握了所有的知识后在优化阶段的选择。</p><h1 id="3-FIFO的实例"><a href="#3-FIFO的实例" class="headerlink" title="3.FIFO的实例"></a>3.FIFO的实例</h1><p> 一：调用IP核的代码<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// synopsys translate_off</span><br><span class="line">`timescale 1 ps / 1 ps</span><br><span class="line">// synopsys translate_on</span><br><span class="line">module IP_demo (</span><br><span class="line">clock,</span><br><span class="line">data,</span><br><span class="line">rdreq,</span><br><span class="line">wrreq,</span><br><span class="line">empty,</span><br><span class="line">full,</span><br><span class="line">q,</span><br><span class="line">usedw);</span><br><span class="line"></span><br><span class="line">input  clock;</span><br><span class="line">input[7:0]  data;</span><br><span class="line">input  rdreq;</span><br><span class="line">input  wrreq;</span><br><span class="line">output  empty;</span><br><span class="line">output  full;</span><br><span class="line">output[7:0]  q;</span><br><span class="line">output[7:0]  usedw;</span><br><span class="line"></span><br><span class="line">wire [7:0] sub_wire0;</span><br><span class="line">wire  sub_wire1;</span><br><span class="line">wire  sub_wire2;</span><br><span class="line">wire [7:0] sub_wire3;</span><br><span class="line">wire [7:0] usedw = sub_wire0[7:0];</span><br><span class="line">wire  empty = sub_wire1;</span><br><span class="line">wire  full = sub_wire2;</span><br><span class="line">wire [7:0] q = sub_wire3[7:0];</span><br><span class="line"></span><br><span class="line">scfifoscfifo_component (</span><br><span class="line">.clock (clock),</span><br><span class="line">.data (data),</span><br><span class="line">.rdreq (rdreq),</span><br><span class="line">.wrreq (wrreq),</span><br><span class="line">.usedw (sub_wire0),</span><br><span class="line">.empty (sub_wire1),</span><br><span class="line">.full (sub_wire2),</span><br><span class="line">.q (sub_wire3),</span><br><span class="line">.aclr (),</span><br><span class="line">.almost_empty (),</span><br><span class="line">.almost_full (),</span><br><span class="line">.sclr ());</span><br><span class="line">defparam</span><br><span class="line">scfifo_component.add_ram_output_register = &quot;OFF&quot;,</span><br><span class="line">scfifo_component.intended_device_family = &quot;Cyclone IV E&quot;,</span><br><span class="line">scfifo_component.lpm_numwords = 256,</span><br><span class="line">scfifo_component.lpm_showahead = &quot;OFF&quot;,</span><br><span class="line">scfifo_component.lpm_type = &quot;scfifo&quot;,</span><br><span class="line">scfifo_component.lpm_width = 8,</span><br><span class="line">scfifo_component.lpm_widthu = 8,</span><br><span class="line">scfifo_component.overflow_checking = &quot;ON&quot;,</span><br><span class="line">scfifo_component.underflow_checking = &quot;ON&quot;,</span><br><span class="line">scfifo_component.use_eab = &quot;ON&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p><img src="/2019/10/21/IP核的调用/imag1.png"><h1 id="4-testbech的模式"><a href="#4-testbech的模式" class="headerlink" title="4.testbech的模式"></a>4.testbech的模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns</span><br><span class="line">module IP_demo_tb;</span><br><span class="line">reg clock;</span><br><span class="line">reg rdreq;</span><br><span class="line">reg wrreq;</span><br><span class="line">reg [7:0] data;</span><br><span class="line"></span><br><span class="line">wire empty;</span><br><span class="line">wire full;</span><br><span class="line">wire [7:0] q;</span><br><span class="line">wire [7:0] usedw;</span><br><span class="line">IP_demo M1(</span><br><span class="line">.clock(clock),</span><br><span class="line">.data(data),</span><br><span class="line">.rdreq(rdreq),</span><br><span class="line">.wrreq(wrreq),</span><br><span class="line">.empty(empty),</span><br><span class="line">.full(full),</span><br><span class="line">.q(q),</span><br><span class="line">.usedw(usedw)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>具体的测试就不做了，这种成熟的模块学会利用就好。</p><h1 id="5-结果"><a href="#5-结果" class="headerlink" title="5.结果"></a>5.结果</h1><p>  学习IP核的利用作为一个基本的能力，在后面的学习中可以作为辅助的手段以提高设计的层次。但是，归根到底，系统化的知识是必要的，就算自己不会做，但也一定要懂。毕竟初学时过一遍可以有效地降低在大的项目中出现常识性的错误的几率。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;IP核的调用&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;1-IP核的定义&quot;&gt;&lt;a href=&quot;#1-IP核的定义&quot; class=&quot;headerlink&quot; title=&quot;1.IP核的定义&quot;&gt;&lt;/a&gt;1.IP核的定义&lt;/h1&gt;&lt;p&gt;  一些写好的IP核就是构建好的可调整的模块化的代码。利用IP核可以快速的完成一些成熟的功能。这好像在考试是使用简化的公式一样。虽然这是一个比较速成的方法，但是要适当的使用，毕竟在初学时掌握完备的体系是后续的基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>设计流程</title>
    <link href="https://github.com/electricdream11/2019/10/18/%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/electricdream11/2019/10/18/设计流程/</id>
    <published>2019-10-18T14:25:09.000Z</published>
    <updated>2019-10-18T14:34:58.869Z</updated>
    
    <content type="html"><![CDATA[<p>设计流程</p><a id="more"></a><h1 id="一、设计原理"><a href="#一、设计原理" class="headerlink" title="一、设计原理"></a>一、设计原理</h1><img src="/2019/10/18/设计流程/image.png"><h1 id="二、Altera-Quartus-的设计步骤"><a href="#二、Altera-Quartus-的设计步骤" class="headerlink" title="二、Altera Quartus 的设计步骤"></a>二、Altera Quartus 的设计步骤</h1><p>1、设计输入（Design Entry）<br>2、综合（Synthesis）<br>3、布局布线（Fitter）<br>4、仿真（Simulation）<br>5、编程和配置（Programming &amp; Configuration）</p><h1 id="三、标准化的设计目录"><a href="#三、标准化的设计目录" class="headerlink" title="三、标准化的设计目录"></a>三、标准化的设计目录</h1><p>  一级目录–project_name：用于存储所有的工程文件，也是根目录。<br>    二级目录<br>       –src   ：源码<br>       –core ：存放集成环境产生的初始化列表<br>       –dev  ：存放综合和布局布线的结果和中间文件，第                三方工具最好将综合和布局布线做成两个目录<br>       –sim  ：仿真文件<br>           —- 三级目录<br>               ——funcsim  ：功能仿真文件<br>               ——parsim   ：时序仿真文件<br>       –doc  ：设计文档，记录过程</p><h1 id="四、quartus文件类别"><a href="#四、quartus文件类别" class="headerlink" title="四、quartus文件类别"></a>四、quartus文件类别</h1><p>  HDL文件（verilog和VHDL）（存于src）：写模块的主要输入方式<br>  IP 核的语言也是HDl语言，只不过是封装好的。<br>mif文件（存在core）：用于初始化存储器<br>qsf文件（存在dev）：时序和管脚约束文件<br>vwf,vec,tbl文件（存于sim）:矢量波形，矢量文件，矢量输出三类仿真激励文件。<br>暂时要了解的文件格式就这几种，后续的学习中在逐渐的加入。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>  体验实际的设计流程后发现，作为工程，实际的verilog设计是十分的精细的工作，要考虑的东西很多。一步一步的操作需要十分的耐性。此外，后期的优化是十分的困难的。在一步步的了解了FPGA设计的全部的过程后，学习FPGA变得更加的枯燥。不同于编程的纯逻辑的设计，也不同于电路的计算为主的设计思路，HDL更加的要求全面的知识面。<br>  接下来的学习需要更多的电路知识、设计规范和各种辅助工具的利用。总之，FPGA的学习不是简单的，但在学习后的收获是巨大的。细节处要慢慢的磨砺，大方向处要找更多的知识来支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计流程&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="verilog" scheme="https://github.com/electricdream11/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>状态机测试</title>
    <link href="https://github.com/electricdream11/2019/10/16/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%B5%8B%E8%AF%95/"/>
    <id>https://github.com/electricdream11/2019/10/16/状态机测试/</id>
    <published>2019-10-16T15:04:07.000Z</published>
    <updated>2019-10-16T15:18:58.793Z</updated>
    
    <content type="html"><![CDATA[<pre><code>状态机设计</code></pre><h1 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h1><p>  考虑到时序电路中状态机设计思想是一种重要的方法，在许多的时序电路设计中都有应用，在此补上昨天没有构成状态机的遗憾。并且要进一步的掌握状态机的设计思路以便接下来的学习。<br>  <a id="more"></a></p><h1 id="2-实验原理"><a href="#2-实验原理" class="headerlink" title="2.实验原理"></a>2.实验原理</h1><p>  构建一个四状态的状态机，能够实现以下功能：<br>  S1：组合输出1<br>  S2: 组合输出2<br>  S3：组合输出3<br>  S4:  组合输出4</p><h1 id="3-状态机示意图"><a href="#3-状态机示意图" class="headerlink" title="3.状态机示意图"></a>3.状态机示意图</h1>  <img src="/2019/10/16/状态机测试/imag1.png"><h1 id="4-verilog的三段式的代码的实现"><a href="#4-verilog的三段式的代码的实现" class="headerlink" title="4.verilog的三段式的代码的实现"></a>4.verilog的三段式的代码的实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">module state_machine(</span><br><span class="line"> Clk, </span><br><span class="line"> Rst_n,</span><br><span class="line"> I1,</span><br><span class="line"> I2,</span><br><span class="line">  Q</span><br><span class="line">);</span><br><span class="line">input Clk;</span><br><span class="line">input Rst_n;</span><br><span class="line">input I1;</span><br><span class="line">input I2;</span><br><span class="line">output reg [1:0] Q;</span><br><span class="line">/////////////////////////////</span><br><span class="line">parameter [1:0] </span><br><span class="line">     S1=2&apos;b00,</span><br><span class="line">  S2=2&apos;b01,</span><br><span class="line">  S3=2&apos;b10,</span><br><span class="line">  S4=2&apos;b11;</span><br><span class="line">reg [1:0] state;</span><br><span class="line">reg [1:0] state_nx;</span><br><span class="line">////////////////////////////////////</span><br><span class="line">//状态机的三段式</span><br><span class="line">//the way to change about state_now </span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">state &lt;= S1;</span><br><span class="line">else </span><br><span class="line">state &lt;= state_nx;</span><br><span class="line">end</span><br><span class="line">//the way to change about state_next</span><br><span class="line">always@(state or I1 or I2)begin</span><br><span class="line"> state_nx = 2&apos;bx;</span><br><span class="line"> case(state)</span><br><span class="line"> S1: begin </span><br><span class="line">      if(I1)  state_nx =S2;</span><br><span class="line">if(I2)  state_nx =S3;</span><br><span class="line">      end</span><br><span class="line"> S2: begin </span><br><span class="line">     if(!I1) state_nx =S3; </span><br><span class="line">  </span><br><span class="line">  end</span><br><span class="line"> S3: </span><br><span class="line">     begin if(I2)  </span><br><span class="line">  state_nx =S4;</span><br><span class="line"> </span><br><span class="line">  end</span><br><span class="line"> S4: begin </span><br><span class="line">     if(!I2) state_nx =S1; </span><br><span class="line">  if(I2 &amp; I1) state_nx =S3;</span><br><span class="line">  end</span><br><span class="line"> default: state  = S1;</span><br><span class="line"> endcase </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">Q &lt;=2&apos;b00;</span><br><span class="line">else</span><br><span class="line">case(state)</span><br><span class="line">S1: Q &lt;=2&apos;b00;</span><br><span class="line">S2: Q &lt;=2&apos;b01;</span><br><span class="line">S3: Q &lt;=2&apos;b10;</span><br><span class="line">S4: Q &lt;=2&apos;b11;</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line">////////////////////////////////////////////</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/16/状态机测试/imag2.png"><img src="/2019/10/16/状态机测试/imag3.png"><h1 id="5-测试脚本的编写"><a href="#5-测试脚本的编写" class="headerlink" title="5.测试脚本的编写"></a>5.测试脚本的编写</h1><p>由于在状态机的编写时花费的时间较多，testbench就不编写了，测试原理也是比较简单，这次的学习主要还是总结状态机的知识点。</p><h1 id="6-状态机的编写规范（三段式）"><a href="#6-状态机的编写规范（三段式）" class="headerlink" title="6.状态机的编写规范（三段式）"></a>6.状态机的编写规范（三段式）</h1><p>  一、一定要明确现状态、下一状态、状态输出/下一状态输出（组合电路输出，如果要加入时序电路，也改为组合电路控制的时序电路，切忌直接加入时序电路使状态机的时序受到影响）。<br>二、下一状态的确定的条件如果只有一个，在状态机中不会有条件判断且该条件不会视为输入使用。<br>三、状态机的条件改变全部列出，所有的状态列出，所有的下一状态列出，满足了这几个条件才能完整的设计完状态机。</p><h1 id="7-verilog语法的补充"><a href="#7-verilog语法的补充" class="headerlink" title="7.verilog语法的补充"></a>7.verilog语法的补充</h1><p>  从这次的实践中发现在组合语句（assign）中可以实现wire的逻辑计算（！）和位操作（~）。但是不能讲reg类型转到wire，也不能讲wire转到reg，只能实现组合电路的功能。<br>  而在always语句中，加入时钟和使能信号标记，可以实现所有的reg变量的操作，也可以实现wire到reg的数据传输。现在感觉always就是对reg的操作（即reg在过程赋值左边，与assign对应）。</p><table><thead><tr><th>等式左\右</th><th>reg</th><th>wire</th></tr></thead><tbody><tr><td>reg</td><td>always</td><td>always</td></tr><tr><td>wire</td><td>？</td><td>assign</td></tr></tbody></table><h1 id="8-if语句"><a href="#8-if语句" class="headerlink" title="8.if语句"></a>8.if语句</h1><p>   这次在尝试时序电路时总是有if判断语句发生错误，在后面的验证中发现要想使用if语句必须要时刻的建设好相应的电路模型以防将if的判断的优先级打乱以致错误。</p><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>  这次的学习的教训还是挺大的。在写verilog过程中必须时刻的考虑verilog的描述性，切记以其他的编程语言的设计思路编程而脱离电路的对应性。做好电路的对应性是书写verilog代码的根本所在。以后的描述过程中一定要时刻的想到实际的电路，考虑是时序还是组合，if的优先级，变量的reg和wire的转化，case的完备性。以后可能还会接触新的要求。反正一定要在做完一个模块后就能对应一个电路，做完一个模型就能了解相应的功能。心中有电路，才不会犯基本错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;状态机设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;1-实验目的&quot;&gt;&lt;a href=&quot;#1-实验目的&quot; class=&quot;headerlink&quot; title=&quot;1.实验目的&quot;&gt;&lt;/a&gt;1.实验目的&lt;/h1&gt;&lt;p&gt;  考虑到时序电路中状态机设计思想是一种重要的方法，在许多的时序电路设计中都有应用，在此补上昨天没有构成状态机的遗憾。并且要进一步的掌握状态机的设计思路以便接下来的学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>计数时钟</title>
    <link href="https://github.com/electricdream11/2019/10/15/%E8%AE%A1%E6%95%B0%E6%97%B6%E9%92%9F/"/>
    <id>https://github.com/electricdream11/2019/10/15/计数时钟/</id>
    <published>2019-10-15T13:36:34.000Z</published>
    <updated>2019-10-15T14:03:14.318Z</updated>
    
    <content type="html"><![CDATA[<pre><code>数字时钟设计</code></pre><h1 id="1-实验目标"><a href="#1-实验目标" class="headerlink" title="1.实验目标"></a>1.实验目标</h1><p>  了解时序电路的verilog的描述方法<br>  掌握时序电路的调试方法<br>  掌握时序电路设计的基本要求<br>  <a id="more"></a></p><h1 id="2-实验原理"><a href="#2-实验原理" class="headerlink" title="2.实验原理"></a>2.实验原理</h1><p>  根据数字时钟的特点，利用状态图得到状态机，根据状态机完成verilog代码的编写。注意使能信号的控制和时钟信号的选择。<br>  重点要注意状态机和verilog语法的对应关系，要想设计出合理的时序电路并用verilog描述，这是必须要掌握的基本技能。<br>  在设计过程中使用的是模16计数器来说明时序电路在verilog的表示方法，在后面有对这个电路的扩充，使其能够实现常用的秒、分、时的计时功能。<br>  这里需要的信息是芯片时钟频率，这需要查询芯片手册，一般都可以找到。在仿真时可以直接设置相应的频率。</p><h1 id="3-状态图"><a href="#3-状态图" class="headerlink" title="3.状态图"></a>3.状态图</h1><img src="/2019/10/15/计数时钟/imag1.png"><h1 id="4-状态机"><a href="#4-状态机" class="headerlink" title="4.状态机"></a>4.状态机</h1><img src="/2019/10/15/计数时钟/imag2.png"> <h1 id="5-verilog代码实现"><a href="#5-verilog代码实现" class="headerlink" title="5.verilog代码实现"></a>5.verilog代码实现</h1><p> 一、初次尝试</p><p>顶端模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module m0001_counter(</span><br><span class="line">Clk,</span><br><span class="line">Rst_n,</span><br><span class="line">Q</span><br><span class="line">);</span><br><span class="line">input Clk;</span><br><span class="line">input Rst_n;</span><br><span class="line">output reg [3:0]Q;</span><br><span class="line">//状态驱动</span><br><span class="line">reg [3:0] state;</span><br><span class="line"></span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">state &lt;= 4&apos;b0;</span><br><span class="line">else if(state == 4&apos;b1111)</span><br><span class="line">state &lt;=4&apos;b0;</span><br><span class="line">else</span><br><span class="line">state &lt;= state +1&apos;b1;</span><br><span class="line">end</span><br><span class="line">//状态控制</span><br><span class="line">always@(*)begin</span><br><span class="line"> Q &lt;= state;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/15/计数时钟/imag4.png"><p>测试文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ms/1ms</span><br><span class="line"></span><br><span class="line">`define Clk_p 1000</span><br><span class="line"></span><br><span class="line">module m0001_counter_tb;</span><br><span class="line">reg Clk;</span><br><span class="line">reg Rst_n;</span><br><span class="line">wire [3:0] Q;</span><br><span class="line">m0001_counter U1(</span><br><span class="line"> .Clk(Clk),</span><br><span class="line"> .Rst_n(Rst_n),</span><br><span class="line"> .Q(Q)</span><br><span class="line">);</span><br><span class="line">initial begin</span><br><span class="line">Clk=1&apos;b0;</span><br><span class="line">Rst_n=1&apos;b1;</span><br><span class="line">end</span><br><span class="line">always#(`Clk_p/2) Clk=~Clk;</span><br><span class="line">initial begin</span><br><span class="line"> #(`Clk_p*10)</span><br><span class="line"> Rst_n=1&apos;b0;</span><br><span class="line"> #(`Clk_p*10)</span><br><span class="line"> Rst_n=1&apos;b1;</span><br><span class="line"> #(`Clk_p*100)</span><br><span class="line"> $stop;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>测试结果：</p><img src="/2019/10/15/计数时钟/imag3.png"><p>结果分析：在状态机设计是没有分析清楚下一状态和现在的状态的区别，导致设计时只考虑了状态的转化关系而没有明确两个寄存器而导致状态机显示不了。<br>二、更改后的顶端文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">module m0001_counter(</span><br><span class="line">Clk,</span><br><span class="line">Rst_n,</span><br><span class="line">Q</span><br><span class="line">);</span><br><span class="line">input Clk;</span><br><span class="line">input Rst_n;</span><br><span class="line">output reg [3:0]Q;</span><br><span class="line">reg [3:0] state;</span><br><span class="line">reg [3:0] state_next;</span><br><span class="line">parameter [3:0]</span><br><span class="line">          Min= 4&apos;b0000,</span><br><span class="line">      Max=4&apos;b1111;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">       </span><br><span class="line">//状态</span><br><span class="line">always@(posedge Clk or negedge Rst_n)begin</span><br><span class="line">if(!Rst_n)</span><br><span class="line">state &lt;= Min;</span><br><span class="line">else</span><br><span class="line">state &lt;= state_next;</span><br><span class="line">end</span><br><span class="line">//下一状态</span><br><span class="line">always@(state)begin</span><br><span class="line">if(state == Max)</span><br><span class="line">state_next = Min;</span><br><span class="line">else </span><br><span class="line">state_next =  state + 4&apos;b1;</span><br><span class="line">end</span><br><span class="line">//控制输出</span><br><span class="line">always@(*)</span><br><span class="line">begin</span><br><span class="line">Q = state;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/15/计数时钟/imag5.png"><p>三、改后的说明<br> 由于verilog代码对状态机的读取需要标准的verilog语法，所以以上的代码还是无法显示出状态机的图示来。但上述的写法展示了状态机标准的三段式写法。由于状态过多且计数器可以使用简单逻辑实现，这次就不一一的列举去找出状态机了。</p><h1 id="6-localparam和parameter语法"><a href="#6-localparam和parameter语法" class="headerlink" title="6.localparam和parameter语法"></a>6.localparam和parameter语法</h1><p>  这两个关键词都是用于声明常量的。和C语言中的define的功能基本相同。同样可以将有意义的常量标记出来以改变。</p><h1 id="7-task语法的使用"><a href="#7-task语法的使用" class="headerlink" title="7.task语法的使用"></a>7.task语法的使用</h1><p> 虽然这次没有写这个关键字，但是在查找资料时遇到了。初步感觉和函数类似，包含了一段可复用的功能块，模式如下：<br>task task_name;<br>……;//功能语句<br>emdtask</p><h1 id="8-计数器（时钟）与状态机的区别："><a href="#8-计数器（时钟）与状态机的区别：" class="headerlink" title="8.计数器（时钟）与状态机的区别："></a>8.计数器（时钟）与状态机的区别：</h1><p>   在verilog中，计数器是比较常见的结构，可以利用基本的加法实现系统时钟的计数。但是状态机则是一种描述思想而不是一种功能结构。使用状态机的条件是所有的状态都已知且转化条件已知，每种状态下的输出已知。在quartus中有严格的状态机写法以便状态机的图示。相比较下，计数器或其他的模块可以利用值得变化来显示状态，要比状态机灵活，但在面对复杂的控制转化关系式容易混乱。总之，描述状态可以使用状态机（一一列举）和变量标记（关系式变化）两种方法解决。</p><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h1><p>  这次的实验基本上达到既定的目标，在区分了状态的两种描述方法和实现对verilog语法的熟悉的基础上了解了时序电路的特点。同时，相应的测试脚本也练习了一下。在这次的学习后，越发的发现verilog与C语言之间的区别。在描述的方法上，verilog采用module区分层次，构建大规模电路。采用task实现代码的重用，提高编程效率。在写verilog代码时就像在连电路图一样。写C语言是则时刻考虑的是变量的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;数字时钟设计&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;1-实验目标&quot;&gt;&lt;a href=&quot;#1-实验目标&quot; class=&quot;headerlink&quot; title=&quot;1.实验目标&quot;&gt;&lt;/a&gt;1.实验目标&lt;/h1&gt;&lt;p&gt;  了解时序电路的verilog的描述方法&lt;br&gt;  掌握时序电路的调试方法&lt;br&gt;  掌握时序电路设计的基本要求&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>三人表决器</title>
    <link href="https://github.com/electricdream11/2019/10/14/%E4%B8%89%E4%BA%BA%E8%A1%A8%E5%86%B3%E5%99%A8/"/>
    <id>https://github.com/electricdream11/2019/10/14/三人表决器/</id>
    <published>2019-10-14T13:25:26.000Z</published>
    <updated>2019-10-15T14:04:04.716Z</updated>
    
    <content type="html"><![CDATA[<p> 三人表决器的设计分析</p><h1 id="1-学习目标"><a href="#1-学习目标" class="headerlink" title="1.学习目标"></a>1.学习目标</h1><p>  了解规范的设计流程<br>  熟悉软件部分工具<br>  为接下来的实际设计做准备<br>  <a id="more"></a></p><h1 id="2-实验要求"><a href="#2-实验要求" class="headerlink" title="2.实验要求"></a>2.实验要求</h1><p>   采用真值表和最简公式实现三人表决器，并使用分层模块结构书写代码，完成仿真测试。<br>3.实验原理<br>   多人表决器的真值表</p><img src="/2019/10/14/三人表决器/imag5.png"><p>卡诺图</p><img src="/2019/10/14/三人表决器/imag6.png"><p>逻辑式<br>Q=AB+BC+AC;<br>4.verilog代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module  m_000( A , B , C , Q1,Q2 );</span><br><span class="line">input A;</span><br><span class="line">input B;</span><br><span class="line">input C;</span><br><span class="line"></span><br><span class="line">output Q1;</span><br><span class="line">output Q2;</span><br><span class="line">m_000_1 m_U1(</span><br><span class="line">.m_1_A(A),</span><br><span class="line">.m_1_B(B),</span><br><span class="line">.m_1_C(C),</span><br><span class="line">.m_1_Q(Q1)</span><br><span class="line">);</span><br><span class="line">m_000_2 m_U2(</span><br><span class="line">.m_2_A(A),</span><br><span class="line">.m_2_B(B),</span><br><span class="line">.m_2_C(C),</span><br><span class="line">.m_2_Q(Q2)</span><br><span class="line">);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/14/三人表决器/imag1.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module m_000_1(</span><br><span class="line">input m_1_A,</span><br><span class="line">input m_1_B,</span><br><span class="line">input m_1_C,</span><br><span class="line">output m_1_Q</span><br><span class="line">);</span><br><span class="line">assign m_1_Q= (m_1_A || m_1_B) &amp;&amp; (m_1_A || m_1_C ) &amp;&amp; (m_1_B || m_1_C);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/14/三人表决器/imag2.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">module m_000_2(</span><br><span class="line">input m_2_A,</span><br><span class="line">input m_2_B,</span><br><span class="line">input m_2_C,</span><br><span class="line">output reg m_2_Q</span><br><span class="line">);</span><br><span class="line">wire [2:0]temp;</span><br><span class="line">assign temp[0]=m_2_A;</span><br><span class="line">assign temp[1]=m_2_B;</span><br><span class="line">assign temp[2]=m_2_C;</span><br><span class="line">always@(*)begin</span><br><span class="line">case(temp)</span><br><span class="line">3&apos;b000: m_2_Q = 1&apos;b0;</span><br><span class="line">3&apos;b001: m_2_Q = 1&apos;b0;</span><br><span class="line">3&apos;b010: m_2_Q = 1&apos;b0;</span><br><span class="line">3&apos;b011: m_2_Q = 1&apos;b1;</span><br><span class="line">3&apos;b100: m_2_Q = 1&apos;b0;</span><br><span class="line">3&apos;b101: m_2_Q = 1&apos;b1;</span><br><span class="line">3&apos;b110: m_2_Q = 1&apos;b1;</span><br><span class="line">3&apos;b111: m_2_Q = 1&apos;b1; //为了体现真值表的特性不缩写</span><br><span class="line">endcase</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><img src="/2019/10/14/三人表决器/imag3.png"><h1 id="5-testbanch的编写"><a href="#5-testbanch的编写" class="headerlink" title="5.testbanch的编写"></a>5.testbanch的编写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ns  </span><br><span class="line"></span><br><span class="line">module m_000_tb;</span><br><span class="line">reg A;</span><br><span class="line">reg B;</span><br><span class="line">reg C;</span><br><span class="line">wire Q1;</span><br><span class="line">wire Q2;</span><br><span class="line">m_000 m_000_tb1(</span><br><span class="line">.A(A),</span><br><span class="line">.B(B),</span><br><span class="line">.C(C),</span><br><span class="line">.Q1(Q1),</span><br><span class="line">.Q2(Q2)</span><br><span class="line">);</span><br><span class="line">initial begin</span><br><span class="line">A=1&apos;b1;</span><br><span class="line">B=1&apos;b1;</span><br><span class="line">C=1&apos;b0;</span><br><span class="line">#200</span><br><span class="line">A=1&apos;b0;</span><br><span class="line">B=1&apos;b1;</span><br><span class="line">C=1&apos;b0;</span><br><span class="line">#200</span><br><span class="line">$stop;</span><br><span class="line">end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h1 id="6-实验结果"><a href="#6-实验结果" class="headerlink" title="6.实验结果"></a>6.实验结果</h1><img src="/2019/10/14/三人表决器/imag4.png"><h1 id="7-结果分析"><a href="#7-结果分析" class="headerlink" title="7.结果分析"></a>7.结果分析</h1><p>  由于电路比较简单，就是验证了一下输出的两种情况。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h1><p> verilog在组合电路中的描述主要就是这两种方法，掌握好这两种方法对组合电路的设计具有重要的意义。软件工具的熟悉也可以使设计的效率大幅提高。还有一些基础的语法必须要掌握，在仿真时由于基础的语法耽误时间是比较遗憾的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 三人表决器的设计分析&lt;/p&gt;
&lt;h1 id=&quot;1-学习目标&quot;&gt;&lt;a href=&quot;#1-学习目标&quot; class=&quot;headerlink&quot; title=&quot;1.学习目标&quot;&gt;&lt;/a&gt;1.学习目标&lt;/h1&gt;&lt;p&gt;  了解规范的设计流程&lt;br&gt;  熟悉软件部分工具&lt;br&gt;  为接下来的实际设计做准备&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="example" scheme="https://github.com/electricdream11/tags/example/"/>
    
  </entry>
  
  <entry>
    <title>verilog语法设计注意事项</title>
    <link href="https://github.com/electricdream11/2019/10/11/verilog%E8%AF%AD%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://github.com/electricdream11/2019/10/11/verilog语法设计注意事项/</id>
    <published>2019-10-11T13:35:41.000Z</published>
    <updated>2019-10-11T13:40:29.629Z</updated>
    
    <content type="html"><![CDATA[<pre><code>硬件语法之verilog</code></pre><h1 id="1-verilog与VHDL的区别"><a href="#1-verilog与VHDL的区别" class="headerlink" title="1.verilog与VHDL的区别"></a>1.verilog与VHDL的区别</h1><p> verilog类似c语言，VHDL更为严谨。在学习了verilog后要学习VHDL以提高个人的描述能力。verilog与C语言的区别在于同时执行和顺序执行。在设计verilog时必须要记住设计的对象是电路。</p><a id="more"></a><h1 id="2-verilog中的逻辑系统"><a href="#2-verilog中的逻辑系统" class="headerlink" title="2.verilog中的逻辑系统"></a>2.verilog中的逻辑系统</h1><p>  verilog中包含 0 ， 1 ，X ， Z，四种逻辑系统，用于描述电路中所有的信号的类型。0和1位常见的高低电平，X为未知电平（一般出现在某些错误纠正中），Z为高阻（悬空）接口。</p><h1 id="3-verilog的数据类型"><a href="#3-verilog的数据类型" class="headerlink" title="3.verilog的数据类型"></a>3.verilog的数据类型</h1><p>  reg类型，过程变量，在always和initial中可以赋值传递。（integer和real也是寄存器类型的一种）；<br>  对应的，wire类型，连续变量，在assign中可以作为被赋值项。（同类型的变量还有 wand和tri）；<br>  还有就是参数数据类型（常量），用于说明所用的常量的物理意义，由语句parameter或localparam声明</p><h1 id="4-verilog中的运算"><a href="#4-verilog中的运算" class="headerlink" title="4. verilog中的运算"></a>4. verilog中的运算</h1><p>  算数运算符（加减乘除）：对应硬件电路中的加（减乘除）法器，暂时还没接触到积分和微分器。<br>  关系运算符（大于等于和小于）：用于对变量间的比较，对应比较器，逻辑等于和逻辑不等于暂时没有接触。<br>  逻辑运算符（与或非及对应的逻辑关系）：对应与或非门，注意取反操作是位操作，对所有位有效。而非逻辑只判断真假。<br>  条件运算符（if—else和switch case和 ： ？）：和电路中的选择器对应<br>  位运算符（&amp;，|，~， ^）： 对应多个与或非门，实现所有位的操作。<br>  移位运算符（ &lt;&lt; , &gt;&gt;）：对应移位寄存器<br>  拼接运算符（，｛｝｛｛｝｝）：对应寄存器的同步组合，｛,｝为前后拼接，｛a｛b｝｝，重复拼接运算符，将b拼接a次；</p><h1 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5.运算符的优先级"></a>5.运算符的优先级</h1><p>  基本上和C语言的优先级一样，括号的优先级判断依旧存在。</p><h1 id="6-verilog的可综合的关键字"><a href="#6-verilog的可综合的关键字" class="headerlink" title="6.verilog的可综合的关键字"></a>6.verilog的可综合的关键字</h1><p>  一、module和endmodule：模块开始和结束声明<br>二、input和output和inout：端口输入和输出声明<br>三、wire和reg：数据类型声明<br>四、parameter：常量声明<br>五、always和assign：过程和连续赋值标志<br>六、if else和 case default endcase：条件语句声明语句<br>七、begin end ：多过程赋值语句标志<br>八、posedge和negedge or ：上下边沿触发标志（or可以增加条件）</p><h1 id="7-verilog的基本框架"><a href="#7-verilog的基本框架" class="headerlink" title="7.verilog的基本框架"></a>7.verilog的基本框架</h1><p>  一、模块<br>   构成verilog代码的基本单元，也是对应一个具有完整功能的电路。模块的框架基本上包括输入、输出、功能三大部分。前两个部分作为标准化的接口供其他模块或更高级的模块使用，使设计可以不断地累加直到可以实现预计的功能。<br>二、模块的级别<br>   对于一个比较大的电路设计而言，具有层次的设计是必须的，而verilog中都是以模块来实现的，这使得模块在设计之初就要确定好描述的等级。verilog语法中支持<br>（1）系统级：复杂功能电路<br>（2）算法级：功能电路<br>（3）RTL   ：寄存器电路<br>（4）门级  ：逻辑电路<br>（5）开关级：开关电路<br>三、模块的描述方法<br>一、结构化描述：直接利用电路的自带的结构<br>二、数据流描述：又称寄存器级传输（RTL），直接基于输入输出得到寄存器所需的操作。<br>三、行为级描述：由所需的功能得到输入输出的值然后实现相应的功能。</p><h1 id="8-verilog的模块化设计"><a href="#8-verilog的模块化设计" class="headerlink" title="8.verilog的模块化设计"></a>8.verilog的模块化设计</h1><p>   所谓的模块化设计就是设计分层进行，在顶层模块中声明所需的功能，在次级模块中构建好，在顶层中例化即可，这样可以有效地利用重复的功能模块。例子如下（类似C++类的使用）<br>module Example<br>(<br>input a,<br>input b,<br>output s,<br>output q<br>);<br>Yumen Yumen_U1(<br>  .yumen_a(a),  //模块间的链接语法<br>  .yumen_b(b),<br>  .yumen_q(q)<br>);<br>Huomen Huomen_U2(<br> .huomen_a(a),<br> .huomen_b(b),<br> .huomen_s(s)<br>);<br>endmodule</p><img src="/2019/10/11/verilog语法设计注意事项/imag1.png"><p>module Yumen(<br>input yumen_a,<br>input yumen_b,<br>output yumen_q<br>);<br>assign yumen_q = yumen_a &amp;&amp; yumen_b ;<br>endmodule</p><img src="/2019/10/11/verilog语法设计注意事项/imag2.png"><p>module Huomen(<br>input huomen_a,<br>input huomen_b,<br>output huomen_s<br>);<br>assign huomen_s = huomen_a || huomen_b ;<br>endmodule</p><img src="/2019/10/11/verilog语法设计注意事项/imag3.png"><h1 id="9-reg与wire在设计中的区分"><a href="#9-reg与wire在设计中的区分" class="headerlink" title="9.reg与wire在设计中的区分"></a>9.reg与wire在设计中的区分</h1><p>  reg 为寄存器类型（在2001verilog中显示为varible），只能作为过程量在always等过程语句中被赋值，同理wire只能在assign等连续语句中被赋值。与此同时，输入端的数据也要同步（wire驱动，reg寄存）；</p><h1 id="10-设计中锁存器的产生"><a href="#10-设计中锁存器的产生" class="headerlink" title="10.设计中锁存器的产生"></a>10.设计中锁存器的产生</h1><p>  在设计条件语句时要考虑所有的情况以免由于系统默认未定义的结果保持不变而形成锁存器。</p><h1 id="11-组合电路的反馈环"><a href="#11-组合电路的反馈环" class="headerlink" title="11.组合电路的反馈环"></a>11.组合电路的反馈环</h1><p> 正如RS锁存器的冒险一样，如果设计的逻辑反馈会导致不确定的值存在，就会形成反馈环，这种会导致警告。设计组合电路的输出转接到输入时要考虑这个问题的存在。</p><h1 id="12-阻塞与非阻塞"><a href="#12-阻塞与非阻塞" class="headerlink" title="12.阻塞与非阻塞"></a>12.阻塞与非阻塞</h1><p>  组合电路中按顺序实现功能即为阻塞赋值，而时序电路中并行执行的是非阻塞赋值。</p><h1 id="13-状态机的设计思想"><a href="#13-状态机的设计思想" class="headerlink" title="13.状态机的设计思想"></a>13.状态机的设计思想</h1><p>  所谓的状态机就是基于时序管理事件的一种描述方法。一般来说，状态机包括状态描述变量，结果变量和控制变量。其中的状态变量相对的独立，其他两个变量在状态机中为关键的设计部分。</p><h1 id="14-代码风格"><a href="#14-代码风格" class="headerlink" title="14.代码风格"></a>14.代码风格</h1><p>  一、命名：这是可读性的直接影响因素，好的命名一目了然，差的命名给人以困惑，在团队项目中尤为致命。<br>二、排版：有相对简洁固定的排版可以大幅的提高代码的整洁度，从而让其他的成员能够快速的掌握关键的代码，提高交流效率。<br>三、注释：事实上，标准的硬件代码的注释要达到代码总量的五分之一，良好的注释是团队项目的基石。<br>总之，写的代码必须能够经得起考验，否则就是乱码。</p><h1 id="15-总结"><a href="#15-总结" class="headerlink" title="15.总结"></a>15.总结</h1><p>  verilog语法是借用了C语言的硬件描述语言，在书写和应用是要时刻的考虑硬件的特点，时刻对应到具体的电路，只有这样才不会脱离实际的电路。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;硬件语法之verilog&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;1-verilog与VHDL的区别&quot;&gt;&lt;a href=&quot;#1-verilog与VHDL的区别&quot; class=&quot;headerlink&quot; title=&quot;1.verilog与VHDL的区别&quot;&gt;&lt;/a&gt;1.verilog与VHDL的区别&lt;/h1&gt;&lt;p&gt; verilog类似c语言，VHDL更为严谨。在学习了verilog后要学习VHDL以提高个人的描述能力。verilog与C语言的区别在于同时执行和顺序执行。在设计verilog时必须要记住设计的对象是电路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="verilog" scheme="https://github.com/electricdream11/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>时序电路基础</title>
    <link href="https://github.com/electricdream11/2019/10/10/%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/electricdream11/2019/10/10/时序电路基础/</id>
    <published>2019-10-10T13:11:32.000Z</published>
    <updated>2019-10-10T13:42:34.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时序电路基础篇"><a href="#时序电路基础篇" class="headerlink" title="时序电路基础篇"></a>时序电路基础篇</h1><h2 id="1-时序电路与组合电路的区别"><a href="#1-时序电路与组合电路的区别" class="headerlink" title="1.时序电路与组合电路的区别"></a>1.时序电路与组合电路的区别</h2><p>  时序电路具有记忆功能，在配合组合电路后可以实现完整的数字电路功能。存储电路有触发器（脉冲边触发）和锁存器（电平触发）两种类型。<br>  <a id="more"></a></p><h2 id="2-锁存器"><a href="#2-锁存器" class="headerlink" title="2.锁存器"></a>2.锁存器</h2><p> 一、RS锁存器：与非门组成的锁存器和或非门组成的锁存器<br>     可以用特性表和特征方程表示<br>     最后可以用状态图表示。<br> 二、门控RS锁存器<br>     加入了使能信号的RS锁存器<br> 三、D锁存器<br>      具有跟随功能的锁存器</p><h2 id="3-空翻现象"><a href="#3-空翻现象" class="headerlink" title="3.空翻现象"></a>3.空翻现象</h2><p>  锁存器由于内部结构导致的系统的误操作。</p><h2 id="4-触发器"><a href="#4-触发器" class="headerlink" title="4.触发器"></a>4.触发器</h2><p>  利用主从触发器实现状态的有效变化。</p><h2 id="5-触发器的verilog描述"><a href="#5-触发器的verilog描述" class="headerlink" title="5.触发器的verilog描述"></a>5.触发器的verilog描述</h2><p> module Digital_Data_Flip_Flop (<br>  Clk, Rst_n, D,Q<br>);<br>input Clk;<br>input Rst_n;<br>input D;<br>output Q;<br>always@(posedge Clk or negedge Rst_n)begin<br>if(!Rst_n)<br>Q &lt;=1’b0;<br>else<br>Q &lt;=D;<br>end<br>endmodule<br>//时序电路使用 非阻塞（&lt;=），而组合电路使用 阻塞电路<br>//（=）</p><img src="/2019/10/10/时序电路基础/imag1.png"><h2 id="6-寄存器"><a href="#6-寄存器" class="headerlink" title="6.寄存器"></a>6.寄存器</h2><p>  使用多个触发器构成的多位二进制码的时序电路</p><p>移位寄存器，可以实现将输出移位。<br>7.寄存器的verilog描述<br>module Digital_Shift_Reg(<br>Clk,Rst_n,Data_en,Data_in,Data_out<br>);<br>input   Clk;<br>input   Rst_n;<br>input   Data_en;<br>input   Data_in;<br>output reg [3:0] Data_out;</p><p>reg [3:0] Data_out_n;</p><p>always@(posedge Clk or negedge Rst_n)begin<br>if(!Rst_n)<br>Data_out &lt;=4’b0;<br>else<br>Data_out &lt;= Data_out_n;<br>end<br>always@(*)begin<br>if(Data_en)<br>  Data_out_n = {Data_out[2:0] ,Data_in};<br>                           //位拼接运算符，用于<br>                           //实现寄存器变量的位拼接<br>else<br> Data_out_n = Data_out;<br>end</p><p>endmodule</p><img src="/2019/10/10/时序电路基础/imag2.png"><h2 id="8-计数器的verilog描述"><a href="#8-计数器的verilog描述" class="headerlink" title="8.计数器的verilog描述"></a>8.计数器的verilog描述</h2><p>module Digital_Counter(<br>     Clk,Rst_n,q<br> );<br>input   Clk;<br>input   Rst_n;<br>output  wire [3:0] q;</p><p>reg  [3:0]  time_cnt;<br>reg  [3:0]  time_cnt_n;<br>//时序电路<br>always@(posedge Clk or negedge Rst_n)begin<br>  if(!Rst_n)<br>  time_cnt &lt;=4’b0;<br>  else<br>  time_cnt &lt;= time_cnt_n;<br>end<br>//组合电路<br>always@(*)begin<br>  if(time_cnt == 4’hf)<br>  time_cnt_n =4’b0;<br>  else<br>  time_cnt_n = time_cnt +1’b1;<br>end<br>//连线电路<br>assign q =time_cnt_n;  //assign将wire作为被赋值端，always<br>                      //将reg作为被赋值端<br>endmodule</p><img src="/2019/10/10/时序电路基础/imag3.png"><h2 id="9-时序电路分析方法"><a href="#9-时序电路分析方法" class="headerlink" title="9.时序电路分析方法"></a>9.时序电路分析方法</h2><p> 摩尔型电路：基于驱动方程、输出方程、状态方程构成的时序电路方程。包含存储和组合两部分的电路。<br> 米里型电路：加入了输入变量的摩尔型电路<br> 实际的问题的一般的解决方法：状态机直接得到设计原理</p><h2 id="10-时序电路总结"><a href="#10-时序电路总结" class="headerlink" title="10.时序电路总结"></a>10.时序电路总结</h2><p> 在基本的时序电路设计中有状态机即可完成所有的时序存储工作，<br> 加上组合电路的真值表或表达式可以完成组合电路部分，加起来即可实现整个电路的设计工作。但这只是简单电路的解决方法，对于复杂的逻辑电路设计则是要充分利用EDA工具提高设计效率。这部分的电路学习更多的偏向于理论的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时序电路基础篇&quot;&gt;&lt;a href=&quot;#时序电路基础篇&quot; class=&quot;headerlink&quot; title=&quot;时序电路基础篇&quot;&gt;&lt;/a&gt;时序电路基础篇&lt;/h1&gt;&lt;h2 id=&quot;1-时序电路与组合电路的区别&quot;&gt;&lt;a href=&quot;#1-时序电路与组合电路的区别&quot; class=&quot;headerlink&quot; title=&quot;1.时序电路与组合电路的区别&quot;&gt;&lt;/a&gt;1.时序电路与组合电路的区别&lt;/h2&gt;&lt;p&gt;  时序电路具有记忆功能，在配合组合电路后可以实现完整的数字电路功能。存储电路有触发器（脉冲边触发）和锁存器（电平触发）两种类型。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="verilog" scheme="https://github.com/electricdream11/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>FPGA组合电路基础</title>
    <link href="https://github.com/electricdream11/2019/10/09/FPGA%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/electricdream11/2019/10/09/FPGA组合电路基础/</id>
    <published>2019-10-09T12:41:20.000Z</published>
    <updated>2019-10-10T13:51:11.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FPGA组合电路基础"><a href="#FPGA组合电路基础" class="headerlink" title="FPGA组合电路基础"></a>FPGA组合电路基础</h1><a id="more"></a><h1 id="1-一般的verilog语法结构"><a href="#1-一般的verilog语法结构" class="headerlink" title="1.一般的verilog语法结构"></a>1.一般的verilog语法结构</h1><pre><code>module name</code></pre><p>   (<br>     Name of io<br>);<br>input   ;<br>output   ;</p><p>assign<br>always<br>initial<br>功能描述<br>函数和任务<br>endmodule</p><h1 id="2-基本的电路的实现"><a href="#2-基本的电路的实现" class="headerlink" title="2.基本的电路的实现"></a>2.基本的电路的实现</h1><p>  一、采用连续赋值语句实现门电路<br>   与：&amp;&amp;    或： ||  非 ！（只能使用这几种组合逻辑实现）<br>  实例：<br>  module yumen(a, b, q);<br>   input a;<br>   input b;<br>   output q;<br>   assign q =a &amp;&amp; b;<br>  endmodule</p><img src="/2019/10/09/FPGA组合电路基础/imag1.png"><p>  二、采用门级元件实现门电路<br>   module yumen(a,b,q);<br>    input a;<br>    input b;<br>    output q;<br>  and (q,a,b);   //还有nand(与非) or(或) nor(或非) not(非)<br>                 //xor(异或) nxor(同或)<br>   endmodule<br> <img src="/2019/10/09/FPGA组合电路基础/imag2.png"></p><p> 三、采用过程赋值语句实现门电路<br>   module yumen(a,b,q);<br>    input a;<br>    input b;<br>    output q;<br>     reg q;</p><p>   always@(*)<br>    q =  a &amp;&amp; b;  //q声明reg表明过程赋值，与always相呼应<br>  endmodule</p> <img src="/2019/10/09/FPGA组合电路基础/imag3.png"><p>//任何过程赋值的左侧变量必须是reg，除此之外的都必须是wire</p><h1 id="3-小提示"><a href="#3-小提示" class="headerlink" title="3.小提示"></a>3.小提示</h1><p>硬件语言描述的作用在于描述，而不是设计，要注意不要在没有实际的电路思路时尝试单纯依靠verilog来实现某种功能，会产生许多疑问。</p><h1 id="4-组合逻辑电路的分析和设计"><a href="#4-组合逻辑电路的分析和设计" class="headerlink" title="4.组合逻辑电路的分析和设计"></a>4.组合逻辑电路的分析和设计</h1><p>  使用真值表和卡诺图得到最简的逻辑，<br>  在考虑了功能冒险（两个变量以上变化且输出稳态值保持不变，主要在板级验证上解决）和逻辑冒险（卡诺图有相切项）后，具体的实现。</p><h1 id="5-组合逻辑电路的应用"><a href="#5-组合逻辑电路的应用" class="headerlink" title="5.组合逻辑电路的应用"></a>5.组合逻辑电路的应用</h1><p> 使用case语句的编码器：<br>  module Digitial_Encoder<br>  (<br>    I,O<br>  );<br>  input  wire [7:0]  I;<br>  output  reg [2:0]  O;<br>  always @(*)<br>   begin<br>   case(I)<br>  8’b0000_0001 : O=3’b000;<br>  8’b0000_0010 : O=3’b001;<br> 8’b0000_0100 : O=3’b010;<br> 8’b0000_1000 : O=3’b011;<br> 8’b0001_0000 : O=3’b100;<br> 8’b0010_0000 : O=3’b101;<br> 8’b0100_0000 : O=3’b110;<br> 8’b1000_0000 : O=3’b111;<br>  default: O =3’b000;<br>  endcase<br>  end<br>endmodule</p><img src="/2019/10/09/FPGA组合电路基础/imag4.png"><p>使用if语句的译码器：<br>module Digital_Prime_Encoder(I,O);<br>input wire [7:0] I;<br>output reg [2:0] O;<br>always@(*)<br>begin<br> if(I[7]==1’b0)   O=3’b000;<br>else if(I[6]==1’b0) O=3’b001;<br>else if(I[5]==1’b0) O=3’b010;<br>else if(I[4]==1’b0) O=3’b011;<br>else if(I[3]==1’b0) O=3’b100;<br>else if(I[2]==1’b0) O=3’b101;<br>else if(I[1]==1’b0) O=3’b110;<br>else if(I[0]==1’b0) O=3’b111;<br>else             O=3’b000;</p><p>end<br>endmodule</p><img src="/2019/10/09/FPGA组合电路基础/imag5.png"><h1 id="6-组合电路小结："><a href="#6-组合电路小结：" class="headerlink" title="6.组合电路小结："></a>6.组合电路小结：</h1><p>在声明模型的架构后，选择输入输出端是根据两种数据类型（reg和wire）来选择的。wire用于连续的赋值，数据是同步改变的（可以理解为敏感源为所有变量的过程赋值）。reg类型的数据是可以等待敏感变量发生赋值的，具有相应的延时效应。这样可以有效地区分过程和连续的进程，以此来防止两种类型的赋值发生在同一变量。功能部分的设计则是根据相应的组合电路的真值表或卡诺图公式得到。</p><h1 id="7-运算符号"><a href="#7-运算符号" class="headerlink" title="7.运算符号"></a>7.运算符号</h1><p>（+、-、  /、！（逻辑非）、&amp;（与）、|（或）、^(异或)、%（取模）、&lt;&lt;(逻辑左移)、&lt;（小于）、&lt;=（小于等于）、&gt;（大于））。 取反：（~）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FPGA组合电路基础&quot;&gt;&lt;a href=&quot;#FPGA组合电路基础&quot; class=&quot;headerlink&quot; title=&quot;FPGA组合电路基础&quot;&gt;&lt;/a&gt;FPGA组合电路基础&lt;/h1&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="verilog" scheme="https://github.com/electricdream11/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>verilog语法基础</title>
    <link href="https://github.com/electricdream11/2019/10/06/verilog%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/electricdream11/2019/10/06/verilog语法基础/</id>
    <published>2019-10-06T12:43:27.000Z</published>
    <updated>2019-10-06T13:00:27.048Z</updated>
    
    <content type="html"><![CDATA[<p>Verilog语法基础是学习FPGA的开始</p><a id="more"></a><h1 id="1-verilog-HDL历史"><a href="#1-verilog-HDL历史" class="headerlink" title="1.verilog HDL历史"></a>1.verilog HDL历史</h1><p>  由OVI标准化，IEEE标准</p><h1 id="2-术语："><a href="#2-术语：" class="headerlink" title="2.术语："></a>2.术语：</h1><p>   HDL：硬件描述语言<br>   RTL：寄存器传送级定义<br>   行为建模：功能确定 || 结构化建模：有对应的硬件电路</p><h1 id="3-综合"><a href="#3-综合" class="headerlink" title="3.综合"></a>3.综合</h1><p>  将verilog代码转化为实际电路的过程</p><h1 id="4-语法规则："><a href="#4-语法规则：" class="headerlink" title="4.语法规则："></a>4.语法规则：</h1><p>  大小写和空白敏感</p><h1 id="5-组成："><a href="#5-组成：" class="headerlink" title="5.组成："></a>5.组成：</h1><p>  端口声明-&gt;数据类型声明-&gt;电路功能-&gt;时序规范</p><h1 id="6-数据类型："><a href="#6-数据类型：" class="headerlink" title="6.数据类型："></a>6.数据类型：</h1><p>  wire 网数据类型（节点）<br>  tri 三态节点<br>  Supply0 和 supply1 常数逻辑值<br>  reg  寄存器数据类型（并不对应物理寄存器，只是类似变量）<br>      只能在进程、任务或功能中赋值reg变量，不能是逻辑门输出和assign输出。</p><h1 id="7-输入输出规则"><a href="#7-输入输出规则" class="headerlink" title="7.输入输出规则"></a>7.输入输出规则</h1><p>Variabletype–input–output–inout<br>net———–Yes—-Yes—–Yes<br>register——No—–Yes—–No</p><h1 id="8-数字"><a href="#8-数字" class="headerlink" title="8.数字"></a>8.数字</h1><p>  <size>’type<num></num></size></p><h1 id="9-位算子"><a href="#9-位算子" class="headerlink" title="9.位算子"></a>9.位算子</h1><p>  ~：每位取反            &amp;：每位与<br>  |：  每位或              ^：异或<br>也有组合缩写算子</p><h1 id="10-算子："><a href="#10-算子：" class="headerlink" title="10.算子："></a>10.算子：</h1><p>  加减乘除取模（%）<br>  相等算子：==，！=，===（条件相等），！==（条件不等，所有的类型）<br>关系算子：</p><blockquote><p> &lt;  =  &gt;=  &lt;=<br>其他算子：包括大部分C语言算子</p></blockquote><h1 id="11-赋值声明："><a href="#11-赋值声明：" class="headerlink" title="11.赋值声明："></a>11.赋值声明：</h1><p>  左手侧（LHS）必须是net类型，右手侧主动的变化</p><h1 id="12-Initial：执行一次模块"><a href="#12-Initial：执行一次模块" class="headerlink" title="12.Initial：执行一次模块"></a>12.Initial：执行一次模块</h1><p>  always：重复执行</p><h1 id="13-进程赋值"><a href="#13-进程赋值" class="headerlink" title="13.进程赋值"></a>13.进程赋值</h1><p>  阻塞按顺序执行，<br>  非阻塞赋值不按顺序执行</p><h1 id="14-组合电路："><a href="#14-组合电路：" class="headerlink" title="14.组合电路："></a>14.组合电路：</h1><p>   对所有事件列表敏感<br>   时序电路：<br>   只对时钟和使能信号敏感</p><h1 id="15-if-else："><a href="#15-if-else：" class="headerlink" title="15.if-else："></a>15.if-else：</h1><p>   使用选择器依次选择条件</p><h1 id="16-case："><a href="#16-case：" class="headerlink" title="16. case："></a>16. case：</h1><p>   多路选择器，不能有交叠重复条件<br>    casez：忽略Z<br>    casex：忽略x和z，不当做逻辑值</p><h1 id="17-Forever："><a href="#17-Forever：" class="headerlink" title="17.Forever："></a>17.Forever：</h1><p>  无限循环，按时间间隔执行</p><h1 id="18-repeat："><a href="#18-repeat：" class="headerlink" title="18.repeat："></a>18.repeat：</h1><p>  有限次数，按次数执行</p><h1 id="19-while："><a href="#19-while：" class="headerlink" title="19.while："></a>19.while：</h1><p>   While的条件是确定的不可更改。</p><h1 id="20-时钟使能和触发器使能"><a href="#20-时钟使能和触发器使能" class="headerlink" title="20. 时钟使能和触发器使能"></a>20. 时钟使能和触发器使能</h1><p>   在敏感列表中申明的信号</p><h1 id="21-函数和任务"><a href="#21-函数和任务" class="headerlink" title="21.函数和任务"></a>21.函数和任务</h1><p>  函数描述了组合功能，任务显示了进程，用于显示这段进程供其他进程。</p><h1 id="22-常用的可综合语法"><a href="#22-常用的可综合语法" class="headerlink" title="22.常用的可综合语法"></a>22.常用的可综合语法</h1><p>常用的RTL语法结构如下：<br>模块声明：module endmodule.<br>端口声明：input，output，inout（inout的用法比较特殊，需要注意）。<br>信号类型：wire，reg，tri等，integer 常用语for语句中（reg，wire是最常用的，一般tri和integer用在测试脚本里）。<br>参数定义：paraneter，define。<br>运算操作符：各种逻辑操作符、移位操作符、算术操作符大多时可综合的（注：===与!==是不可综合的）。<br>比较判断：if else，case（casex，casez）default endcase.<br>连续赋值：assign，问号表达式（？：）。<br>always模块：（敏感表可以为电平、沿信号posedge/negedge；通常和0连用）。<br>Begin end（通俗的说，它就是C语言里的“{}”）。<br>任务定义：task endtask。<br>循环语句：for（用的也比较少，但是在一些特定的设计中使用它会起到事半功倍的效果）。<br>赋值符号：=和&lt;=（阻塞和非阻塞赋值，在具体设计中时很有讲究的）。</p><h1 id="22-实际的例子"><a href="#22-实际的例子" class="headerlink" title="22.实际的例子"></a>22.实际的例子</h1><p>module(<br>       a,<br>         b,</p><pre><code>  c);</code></pre><p> input reg a;<br> input wire b;  </p><p> output wire c;<br> assign c &lt;= a&b; //assign 左侧必须是wire类型</p><p>endmodule</p><p>module(<br>       Clk,<br>         Rst_n,</p><pre><code>   cnt);</code></pre><p>  input clk;<br>  input Rst_n;</p><p>  output cnt;   //output默认为wire类型，<br>                //  要赋值是需要申明为reg</p><p>  reg cnt;<br>  always@(posedge Clk or negedge Rst_n)<br>  begin<br>  if(!Rst_n)<br>  else<br>  cnt &lt;=Clk;<br>  end<br>endmodule</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Verilog语法基础是学习FPGA的开始&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
      <category term="verilog" scheme="https://github.com/electricdream11/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>可编程逻辑基础</title>
    <link href="https://github.com/electricdream11/2019/10/06/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/electricdream11/2019/10/06/可编程逻辑基础/</id>
    <published>2019-10-06T07:39:27.000Z</published>
    <updated>2019-10-06T11:08:07.194Z</updated>
    
    <content type="html"><![CDATA[<p>可编程逻辑器件</p><h1 id="1-可编程逻辑器件将电路连线简化。"><a href="#1-可编程逻辑器件将电路连线简化。" class="headerlink" title="1.可编程逻辑器件将电路连线简化。"></a>1.可编程逻辑器件将电路连线简化。</h1><h1 id="2-CPLD与FPGA的原理：化简电路后级联。"><a href="#2-CPLD与FPGA的原理：化简电路后级联。" class="headerlink" title="2.CPLD与FPGA的原理：化简电路后级联。"></a>2.CPLD与FPGA的原理：化简电路后级联。</h1><a id="more"></a> <h1 id="3-逻辑器件的历史："><a href="#3-逻辑器件的历史：" class="headerlink" title="3.逻辑器件的历史："></a>3.逻辑器件的历史：</h1><p>一、TTL逻辑设计：<br>采用真值表构建模型，利用卡诺图化简后得到逻辑表达式。TTL采用乘积和的模式设计，组成与门和多或门组成。<br>二、PAL可编程阵列逻辑：<br>逻辑门与输出寄存器固定，输入与与门构成乘积项，与乘积项和寄存项构成宏单元。跨线编程依靠浮珊晶体管（FAMOS或FLOTOX），工作方式分别为电擦除和紫光擦除。<br>三、CPLD复杂可编程逻辑器件：<br>利用可编程逻辑阵列的模块（LAB），<br>并且使用了可控乘积项提高效率。可编程互联阵列（PI）采用EPROM等技术编程。IO模块都采用了更加合理的结构。采用JTAG接口实现ISP（系统编程）。提高了可编程的器件的数量。</p><h1 id="4-从CPLD到FPGA的改善"><a href="#4-从CPLD到FPGA的改善" class="headerlink" title="4.从CPLD到FPGA的改善"></a>4.从CPLD到FPGA的改善</h1><p>一、FPGA的LAB采用逻辑模块来提供单元，并成阵列式的分布于网格线中。<br>二、加入的查找表（LUT）可以有效地提高逻辑器件的利用率。<br>三、可编程的寄存器可以灵活的适应各种逻辑输出。<br>四、FPGA内依靠寄存器链和LAB的级联实现进位，不需要进位逻辑块。<br>五、高级的FPGA采用ALM（自适应逻辑模块），基于LE并包括专用资源和LUT以提高利用效率。<br>六、FPGA中的IO模块支持各种的标准，有电流驱动能力。可设置IO的开漏等等可以提高效率的模块。主要有输入、输出、使能模块。<br>七、存储器模块，嵌入式乘法器，高速收发器等定制的模块<br>八、FPGA的时钟：特殊的结构控制并向器件中的同步逻辑扇出时钟。自带时钟控制模块可以配置时钟资源。<br>九、SRAM单元技术用于实现互联和LUT功能级进行编程。行列互联结是易失的，上电时才可以编程。SRAM编程单元也需要上电后进行编程。</p><h1 id="5-ASIC"><a href="#5-ASIC" class="headerlink" title="5.ASIC"></a>5.ASIC</h1><p>一、Altera ASIC是ASIC，用于测试ASIC系统，可以有效地提高ASIC的开发效率。</p><h1 id="6-CPLD和FPAG的对比。"><a href="#6-CPLD和FPAG的对比。" class="headerlink" title="6.CPLD和FPAG的对比。"></a>6.CPLD和FPAG的对比。</h1><p>  CPLD是非易失编程，FPGA是易失的编程设计。<br>  小中型设计            大型设计</p><h1 id="7-设计流程"><a href="#7-设计流程" class="headerlink" title="7.设计流程"></a>7.设计流程</h1><p>   设计输入-&gt;功能仿真-&gt;综合仿真-&gt;布局布线-&gt;门级仿真（可选）<br>                                             |<br>                                          PCB布局</p><h1 id="8-总结："><a href="#8-总结：" class="headerlink" title="8.总结："></a>8.总结：</h1><p>FPGA提高逻辑设计的速度。</p><img src="/2019/10/06/可编程逻辑基础/PLD_basic.png"> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可编程逻辑器件&lt;/p&gt;
&lt;h1 id=&quot;1-可编程逻辑器件将电路连线简化。&quot;&gt;&lt;a href=&quot;#1-可编程逻辑器件将电路连线简化。&quot; class=&quot;headerlink&quot; title=&quot;1.可编程逻辑器件将电路连线简化。&quot;&gt;&lt;/a&gt;1.可编程逻辑器件将电路连线简化。&lt;/h1&gt;&lt;h1 id=&quot;2-CPLD与FPGA的原理：化简电路后级联。&quot;&gt;&lt;a href=&quot;#2-CPLD与FPGA的原理：化简电路后级联。&quot; class=&quot;headerlink&quot; title=&quot;2.CPLD与FPGA的原理：化简电路后级联。&quot;&gt;&lt;/a&gt;2.CPLD与FPGA的原理：化简电路后级联。&lt;/h1&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/categories/FPGA/"/>
    
    
      <category term="FPGA" scheme="https://github.com/electricdream11/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>1003_FPGA</title>
    <link href="https://github.com/electricdream11/2019/10/03/1003_FPGA/"/>
    <id>https://github.com/electricdream11/2019/10/03/1003_FPGA/</id>
    <published>2019-10-03T12:29:17.000Z</published>
    <updated>2019-10-04T06:24:24.227Z</updated>
    
    <content type="html"><![CDATA[<p>FPGA是这个博客的主要的内容，认真的学习好相应的内容是解决这个问题的关键。不定时的上传一些学习过程可以有效地解决资源不足的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FPGA是这个博客的主要的内容，认真的学习好相应的内容是解决这个问题的关键。不定时的上传一些学习过程可以有效地解决资源不足的问题。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="https://github.com/electricdream11/categories/test/"/>
    
    
      <category term="test" scheme="https://github.com/electricdream11/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>myaim</title>
    <link href="https://github.com/electricdream11/2019/10/03/myaim/"/>
    <id>https://github.com/electricdream11/2019/10/03/myaim/</id>
    <published>2019-10-03T08:01:58.000Z</published>
    <updated>2019-10-04T06:24:55.871Z</updated>
    
    <content type="html"><![CDATA[<p>test for categories</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;test for categories&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="https://github.com/electricdream11/categories/test/"/>
    
    
      <category term="test" scheme="https://github.com/electricdream11/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>myfirstarticle</title>
    <link href="https://github.com/electricdream11/2019/10/02/myfirstarticle/"/>
    <id>https://github.com/electricdream11/2019/10/02/myfirstarticle/</id>
    <published>2019-10-02T08:44:32.000Z</published>
    <updated>2019-10-04T06:25:06.956Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/10/02/myfirstarticle/test.jpg" title="test"><p>测试一下功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/10/02/myfirstarticle/test.jpg&quot; title=&quot;test&quot;&gt;

&lt;p&gt;测试一下功能。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="https://github.com/electricdream11/categories/test/"/>
    
    
      <category term="test" scheme="https://github.com/electricdream11/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>hello blog</title>
    <link href="https://github.com/electricdream11/2019/10/01/hello-blog/"/>
    <id>https://github.com/electricdream11/2019/10/01/hello-blog/</id>
    <published>2019-10-01T04:29:10.000Z</published>
    <updated>2019-10-04T06:24:34.579Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="test" scheme="https://github.com/electricdream11/categories/test/"/>
    
    
      <category term="test" scheme="https://github.com/electricdream11/tags/test/"/>
    
  </entry>
  
</feed>
